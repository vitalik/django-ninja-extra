{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Django Ninja Extra Django Ninja Extra package offers a class-based approach plus extra functionalities that will speed up your RESTful API development with Django Ninja Key features: All Django-Ninja features : Easy : Designed to be easy to use and intuitive. FAST execution : Very high performance thanks to Pydantic and async support . Fast to code : Type hints and automatic docs lets you focus only on business logic. Standards-based : Based on the open standards for APIs: OpenAPI (previously known as Swagger) and JSON Schema . Django friendly : (obviously) has good integration with the Django core and ORM. Plus Extra : Class Based : Design your APIs in a class based fashion. Permissions : Protect endpoint(s) at ease with defined permissions and authorizations at route level or controller level. Dependency Injection : Controller classes supports dependency injection with python Injector or django_injector . Giving you the ability to inject API dependable services to APIController class and utilizing them where needed Requirements Python >= 3.6 django >= 2.1 pydantic >= 1.6 Django-Ninja >= 0.16.1 Full documentation, visit . Sample Project Django-Ninja-Tutorial Project, visit Installation pip install django-ninja-extra After installation, add ninja_extra to your INSTALLED_APPS INSTALLED_APPS = [ ... , 'ninja_extra' , ] Usage In your django project next to urls.py create new api.py file: from ninja_extra import NinjaExtraAPI , api_controller , http_get api = NinjaExtraAPI () # function based definition @api . get ( \"/add\" , tags = [ 'Math' ]) def add ( request , a : int , b : int ): return { \"result\" : a + b } #class based definition @api_controller ( '/' , tags = [ 'Math' ], permissions = []) class MathAPI : @http_get ( '/subtract' ,) def subtract ( self , a : int , b : int ): \"\"\"Subtracts a from b\"\"\" return { \"result\" : a - b } @http_get ( '/divide' ,) def divide ( self , a : int , b : int ): \"\"\"Divides a by b\"\"\" return { \"result\" : a / b } @http_get ( '/multiple' ,) def multiple ( self , a : int , b : int ): \"\"\"Multiples a with b\"\"\" return { \"result\" : a * b } api . register_controllers ( MathAPI ) Now go to urls.py and add the following: ... from django.urls import path from .api import api urlpatterns = [ path ( \"admin/\" , admin . site . urls ), path ( \"api/\" , api . urls ), # <---------- ! ] Interactive API docs Now go to http://127.0.0.1:8000/api/docs You will see the automatic interactive API documentation (provided by Swagger UI ):","title":"Index"},{"location":"#django-ninja-extra","text":"Django Ninja Extra package offers a class-based approach plus extra functionalities that will speed up your RESTful API development with Django Ninja Key features: All Django-Ninja features : Easy : Designed to be easy to use and intuitive. FAST execution : Very high performance thanks to Pydantic and async support . Fast to code : Type hints and automatic docs lets you focus only on business logic. Standards-based : Based on the open standards for APIs: OpenAPI (previously known as Swagger) and JSON Schema . Django friendly : (obviously) has good integration with the Django core and ORM. Plus Extra : Class Based : Design your APIs in a class based fashion. Permissions : Protect endpoint(s) at ease with defined permissions and authorizations at route level or controller level. Dependency Injection : Controller classes supports dependency injection with python Injector or django_injector . Giving you the ability to inject API dependable services to APIController class and utilizing them where needed","title":"Django Ninja Extra"},{"location":"#requirements","text":"Python >= 3.6 django >= 2.1 pydantic >= 1.6 Django-Ninja >= 0.16.1 Full documentation, visit .","title":"Requirements"},{"location":"#sample-project","text":"Django-Ninja-Tutorial Project, visit","title":"Sample Project"},{"location":"#installation","text":"pip install django-ninja-extra After installation, add ninja_extra to your INSTALLED_APPS INSTALLED_APPS = [ ... , 'ninja_extra' , ]","title":"Installation"},{"location":"#usage","text":"In your django project next to urls.py create new api.py file: from ninja_extra import NinjaExtraAPI , api_controller , http_get api = NinjaExtraAPI () # function based definition @api . get ( \"/add\" , tags = [ 'Math' ]) def add ( request , a : int , b : int ): return { \"result\" : a + b } #class based definition @api_controller ( '/' , tags = [ 'Math' ], permissions = []) class MathAPI : @http_get ( '/subtract' ,) def subtract ( self , a : int , b : int ): \"\"\"Subtracts a from b\"\"\" return { \"result\" : a - b } @http_get ( '/divide' ,) def divide ( self , a : int , b : int ): \"\"\"Divides a by b\"\"\" return { \"result\" : a / b } @http_get ( '/multiple' ,) def multiple ( self , a : int , b : int ): \"\"\"Multiples a with b\"\"\" return { \"result\" : a * b } api . register_controllers ( MathAPI ) Now go to urls.py and add the following: ... from django.urls import path from .api import api urlpatterns = [ path ( \"admin/\" , admin . site . urls ), path ( \"api/\" , api . urls ), # <---------- ! ]","title":"Usage"},{"location":"#interactive-api-docs","text":"Now go to http://127.0.0.1:8000/api/docs You will see the automatic interactive API documentation (provided by Swagger UI ):","title":"Interactive API docs"},{"location":"route_context/","text":"Django Ninja Extra provides the RouteContext object, which is available throughout the request lifecycle. This object holds essential properties for the route handler that will handle the request. These properties include the Django HttpRequest object, a list of permission classes for the route handler, a temporary response object used by Django-Ninja to construct the final response, and kwargs and args required for calling the route function. It's important to note that these properties are not set at the beginning of the request, but rather become available as the request progresses through different stages, and before it reaches the route function execution. from pydantic import BaseModel as PydanticModel , Field class RouteContext ( PydanticModel ): \"\"\" APIController Context which will be available to the class instance when handling request \"\"\" class Config : arbitrary_types_allowed = True permission_classes : PermissionType = Field ([]) request : Union [ Any , HttpRequest , None ] = None response : Union [ Any , HttpResponse , None ] = None args : List [ Any ] = Field ([]) kwargs : DictStrAny = Field ({}) How to Access RouteContext In Django Ninja Extra, the RouteContext object can be accessed within the controller class by using the self.context property. This property is available at the instance level of the controller class, making it easy to access the properties and methods of the RouteContext object. For example. from ninja_extra import ControllerBase , api_controller , route from django.db import transaction from ninja_extra.permissions import IsAuthenticated from ninja_jwt.authentication import JWTAuth from django.contrib.auth import get_user_model User = get_user_model () @api_controller ( \"/books\" , auth = JWTAuth (), permissions = [ IsAuthenticated ]) class StoryBookSubscribeController ( ControllerBase ): @route . get ( \"/context\" , url_name = \"subscribe\" , ) @transaction . atomic def subscribe ( self ): user = self . context . request . user return { 'message' : 'Authenticated User From context' , 'email' : user . email } @route . post ( \"/context\" , url_name = \"subscribe\" , ) @transaction . atomic def subscribe_with_response_change ( self ): res = self . context . response res . headers . setdefault ( 'x-custom-header' , 'welcome to custom header in response' ) return { 'message' : 'Authenticated User From context and Response header modified' , 'email' : self . context . request . user . email } In the example, we can access the authenticated user object from the request object in the self.context property, which is available in the controller class. This allows us to easily access the authenticated user's information Modifying Response Header with RouteContext The RouteContext object provides you with the necessary properties and methods to manipulate the response data before it is returned to the client. With the RouteContext object, you can easily modify header, status, or cookie data for the response returned for a specific request For example, lets add extra header info our new endpoint, subscribe_with_response_change as shown below. from ninja_extra import ControllerBase , api_controller , route from django.db import transaction from ninja_extra.permissions import IsAuthenticated from ninja_jwt.authentication import JWTAuth from django.contrib.auth import get_user_model User = get_user_model () @api_controller ( \"/books\" , auth = JWTAuth (), permissions = [ IsAuthenticated ]) class StoryBookSubscribeController ( ControllerBase ): @route . post ( \"/context-response\" , url_name = \"response\" , ) @transaction . atomic def subscribe_with_response_change ( self ): res = self . context . response res . headers [ 'x-custom-header' ] = 'welcome to custom header in response' return { 'message' : 'Authenticated User From context and Response header modified' , 'email' : self . context . request . user . email } Using RouteContext in Schema There may be situations where you need to access the request object during schema validation. Django Ninja Extra makes this easy by providing a way to resolve the RouteContext object during the request, which can then be used to access the request object and any other necessary properties. This allows you to use the context of the request within the validation process, making it more flexible and powerful. For example: from typing import Optional from django.urls import reverse from ninja_extra import service_resolver from ninja_extra.controllers import RouteContext from ninja import ModelSchema from pydantic import AnyHttpUrl , validator class StoreBookSchema ( ModelSchema ): borrowed_by : Optional [ UserRetrieveSchema ] store : AnyHttpUrl book : BookSchema class Config : model = StoreBook model_fields = [ 'borrowed_by' , 'store' , 'book' ] @validator ( \"store\" , pre = True , check_fields = False ) def store_validate ( cls , value_data ): context : RouteContext = service_resolver ( RouteContext ) value = reverse ( \"store:detail\" , kwargs = dict ( store_id = value_data . id )) return context . request . build_absolute_uri ( value ) In the example above, we used the service_resolver , a dependency injection utility function, to resolve the RouteContext object. This gave us access to the request object, which we used to construct a full URL for our store details. By using the service_resolver to access the RouteContext, we can easily access the request object, and use it to gather any necessary information during the validation process.","title":"RouteContext"},{"location":"route_context/#how-to-access-routecontext","text":"In Django Ninja Extra, the RouteContext object can be accessed within the controller class by using the self.context property. This property is available at the instance level of the controller class, making it easy to access the properties and methods of the RouteContext object. For example. from ninja_extra import ControllerBase , api_controller , route from django.db import transaction from ninja_extra.permissions import IsAuthenticated from ninja_jwt.authentication import JWTAuth from django.contrib.auth import get_user_model User = get_user_model () @api_controller ( \"/books\" , auth = JWTAuth (), permissions = [ IsAuthenticated ]) class StoryBookSubscribeController ( ControllerBase ): @route . get ( \"/context\" , url_name = \"subscribe\" , ) @transaction . atomic def subscribe ( self ): user = self . context . request . user return { 'message' : 'Authenticated User From context' , 'email' : user . email } @route . post ( \"/context\" , url_name = \"subscribe\" , ) @transaction . atomic def subscribe_with_response_change ( self ): res = self . context . response res . headers . setdefault ( 'x-custom-header' , 'welcome to custom header in response' ) return { 'message' : 'Authenticated User From context and Response header modified' , 'email' : self . context . request . user . email } In the example, we can access the authenticated user object from the request object in the self.context property, which is available in the controller class. This allows us to easily access the authenticated user's information","title":"How to Access RouteContext"},{"location":"route_context/#modifying-response-header-with-routecontext","text":"The RouteContext object provides you with the necessary properties and methods to manipulate the response data before it is returned to the client. With the RouteContext object, you can easily modify header, status, or cookie data for the response returned for a specific request For example, lets add extra header info our new endpoint, subscribe_with_response_change as shown below. from ninja_extra import ControllerBase , api_controller , route from django.db import transaction from ninja_extra.permissions import IsAuthenticated from ninja_jwt.authentication import JWTAuth from django.contrib.auth import get_user_model User = get_user_model () @api_controller ( \"/books\" , auth = JWTAuth (), permissions = [ IsAuthenticated ]) class StoryBookSubscribeController ( ControllerBase ): @route . post ( \"/context-response\" , url_name = \"response\" , ) @transaction . atomic def subscribe_with_response_change ( self ): res = self . context . response res . headers [ 'x-custom-header' ] = 'welcome to custom header in response' return { 'message' : 'Authenticated User From context and Response header modified' , 'email' : self . context . request . user . email }","title":"Modifying Response Header with RouteContext"},{"location":"route_context/#using-routecontext-in-schema","text":"There may be situations where you need to access the request object during schema validation. Django Ninja Extra makes this easy by providing a way to resolve the RouteContext object during the request, which can then be used to access the request object and any other necessary properties. This allows you to use the context of the request within the validation process, making it more flexible and powerful. For example: from typing import Optional from django.urls import reverse from ninja_extra import service_resolver from ninja_extra.controllers import RouteContext from ninja import ModelSchema from pydantic import AnyHttpUrl , validator class StoreBookSchema ( ModelSchema ): borrowed_by : Optional [ UserRetrieveSchema ] store : AnyHttpUrl book : BookSchema class Config : model = StoreBook model_fields = [ 'borrowed_by' , 'store' , 'book' ] @validator ( \"store\" , pre = True , check_fields = False ) def store_validate ( cls , value_data ): context : RouteContext = service_resolver ( RouteContext ) value = reverse ( \"store:detail\" , kwargs = dict ( store_id = value_data . id )) return context . request . build_absolute_uri ( value ) In the example above, we used the service_resolver , a dependency injection utility function, to resolve the RouteContext object. This gave us access to the request object, which we used to construct a full URL for our store details. By using the service_resolver to access the RouteContext, we can easily access the request object, and use it to gather any necessary information during the validation process.","title":"Using RouteContext in Schema"},{"location":"service_module_injector/","text":"Dependency Injection One of the core features of Django Ninja Extra APIController is its support dependency injection using Injector For example, if you have a service called AuthService and you want to use it in your UsersController class, you can simply add it as a parameter in the constructor of the class and annotate it with its type. class UsersController ( ControllerBase ): def __init__ ( self , auth_service : AuthService ): self . auth_service = auth_service Then in your application config, you can register this service and its scope. By default, services are singleton scoped unless specified. def configure ( binder : Binder ) -> Binder : binder . bind ( AuthService , to = AuthServiceImpl , scope = singleton ) You can also specify the scope of the service. This is useful when you want to use different instances of the same service for different requests. def configure ( binder : Binder ) -> Binder : binder . bind ( AuthService , to = AuthServiceImpl , scope = noscope ) In this way, you can easily inject services into your controllers and use them throughout your application. This makes it easy to test your controllers as well as to change the implementation of a service without affecting the rest of the application. Info Django-Ninja-Extra supports django_injector . There is no extra configuration needed. Creating a Service A service refers to a self-contained module or piece of functionality that can be reused across different parts of an application. Services are typically used to encapsulate business logic or to provide access to shared resources, such as databases or external APIs. Services are often implemented as classes, and they can be accessed through an object-oriented interface. Services can be used to perform actions, to interact with external systems, and to perform calculations. They usually have some public methods and properties, which allows other objects to interact with them. Services are usually used to separate the application logic from the infrastructure, this way the application logic can be reused, tested and maintained independently. Let's create a simple S3 bucket service, create a service.py in your project and add the cold below from ninja import File from ninja.files import UploadedFile from ninja_extra import NinjaExtraAPI , api_controller , http_post class BucketFileUploadService : def upload_file_to_s3 ( self , file , bucket_name = None , acl = \"public-read\" , file_key = None ): pass def upload_existing_file_to_s3 ( self , filepath , file_key , bucket_name = None , acl = \"public-read\" , delete_file_afterwards = False , clean_up_root_limit = None ): pass @api_controller ( '/user_profile' ) class UserProfileController : def __init__ ( self , upload_service : BucketFileUploadService ): self . upload_service = upload_service @http_post ( '/upload' ) def upload_profile_pic ( self , file : UploadedFile = File ( ... )): self . upload_service . upload_file_to_s3 ( file = file ) return { 'message' , 'uploaded successfully' } api = NinjaExtraAPI ( title = 'Injector Test' ) api . register_controllers ( UserProfileController ) Create a module In Python Injector, a module is a class or a function that is used to configure the dependency injection container. A module is responsible for binding services to their implementations and for configuring the scope of services. A module can define a configure(binder: Binder) function that is used to configure the dependency injection container. The binder argument is an instance of the Binder class that is used to bind services to their implementations. A module can also define one or more provider functions, which are used to create instances of services. These functions can be decorated with @inject to specify the dependencies that they need to be resolved, and they can be decorated with @provider to indicate that they should be used to create instances of services. For example: from injector import Binder , singleton , inject , provider class MyModule : def configure ( self , binder : Binder ) -> Binder : binder . bind ( AuthService , to = AuthServiceImpl , scope = singleton ) @provider @inject def provide_user_service ( self , auth_service : AuthService ) -> UserService : return UserService ( auth_service ) In the example above, MyModule class has configure method which is used to bind the AuthService and set the scope as singleton and provide_user_service which is decorated with @provider and @inject to provide UserService and the AuthService is injected to it as a dependency. By registering a module in Ninja Extra settings, all the services, providers and configurations defined in the module will be added to the Injector, and these services can be resolved and used throughout the application. Lets creates a module for the BucketFileUpload service we created earlier. Create a module.py in your project and add the code below. import logging import os from typing import cast from django.conf import Settings from injector import inject , Module , Binder , singleton logger = logging . getLogger () class InMemoryBucketFileUpload ( BucketFileUpload ): @inject def __init__ ( self , settings : Settings ): logger . info ( f \"===== Using InMemoryBucketFileUpload =======\" ) self . settings = settings assert isinstance ( self . settings , Settings ) def upload_file_to_s3 ( self , file , bucket_name = None , acl = \"public-read\" , file_key = None ): logger . info ( f \"InMemoryBucketFileUpload ---- \" f \"upload_file_to_s3(file= { file . filename } , bucket_name { bucket_name } , acl= { acl } , file_key= { file_key } )\" ) if not file_key : return os . path . join ( self . settings . UPLOAD_FOLDER , file . filename ) return os . path . join ( self . settings . BASE_DIR , file_key ) def upload_existing_file_to_s3 ( self , filepath , file_key , bucket_name = None , acl = \"public-read\" , delete_file_afterwards = False , clean_up_root_limit = None ): logger . info ( f \"InMemoryBucketFileUpload ---- upload_existing_file_to_s3(\" f \"filepath= { filepath } , file_key= { file_key } , \" f \"bucket_name= { bucket_name } , acl= { acl } , delete_file_afterwards= { delete_file_afterwards } )\" ) return filepath class FileServiceModule ( Module ): def configure ( self , binder : Binder ) -> None : binder . bind ( BucketFileUpload , to = InMemoryBucketFileUpload , scope = singleton ) We have created a FileServiceModule that binds BucketFileUpload to InMemoryBucketFileUpload . In our application, when BucketFileUpload is resolved we will get an instance of InMemoryBucketFileUpload provided for us by the injector. We also used inject decorator from injector to inject django settings to InMemoryBucketFileUpload service. The InMemoryBucketFileUpload concrete class is a simple class for development. In production time, you meant want to write a better service to saves file to your AWS S3 bucket. Service Scope A scope defines the lifespan of a service created. There are three major scope when working with dependency injection in a web framework singleton scope A singleton service is created only once and the same instance is reused for the entire lifetime of the application. This is the default scope when no scope is specified. from injector import Module , Binder , singleton class FileServiceModule ( Module ): def configure ( self , binder : Binder ) -> None : binder . bind ( BucketFileUpload , to = InMemoryBucketFileUpload , scope = singleton ) transient scope A transient service is created each time it's requested. A new instance is created for each request. This is useful for services that do not maintain state or services that should not be shared across multiple requests. from injector import Module , Binder , noscope class FileServiceModule ( Module ): def configure ( self , binder : Binder ) -> None : binder . bind ( BucketFileUpload , to = InMemoryBucketFileUpload , scope = noscope ) scoped A scoped service is created once per request. A new instance is created for each incoming request and is shared among all components that depend on it within the same request. This is useful for services that maintain request-specific state. Currently, Ninja extra does not support scoped scope service. It's important to choose the appropriate scope when registering services with the dependency injection container. Singleton services are suitable for services that maintain application-wide state, transient services are suitable for services that do not maintain state, and scoped services are suitable for services that maintain request-specific state. Adding Service to Controllers Ninja Extra controllers constructor ( __init__ ) are decorated with inject function from injector library. This makes it possible define parameter in a parameter in the constructor with a type annotation and the annotated type gets injected during object instantiation. We have created a BucketFileUpload contract and some concrete implementations, lets add it to a controller. Lets create a controller.py with the code below from ninja import File from ninja.files import UploadedFile from ninja_extra import NinjaExtraAPI , api_controller , http_post from .modules import BucketFileUpload , InMemoryBucketFileUpload @api_controller ( '/user_profile' ) class UserProfileController : def __init__ ( self , upload_service : BucketFileUpload ): self . upload_service = upload_service @http_post ( '/upload' ) def upload_profile_pic ( self , file : UploadedFile = File ( ... )): self . upload_service . upload_file_to_s3 ( file = file ) assert isinstance ( self . upload_service , InMemoryBucketFileUpload ) # True return { 'message' , 'uploaded successfully' } api = NinjaExtraAPI ( title = 'Injector Test' ) api . register_controllers ( UserProfileController ) Now, we have defined an BucketFileUpload service dependence to our UserProfileController . We need to register FileServiceModule to settings to avoid getting UnsatisedRequirement exception from injector when Ninja extra tries to create the object. Module Registration There are different ways of registering injector Modules in a Django app. django_injector : if you are using django_inject, it has documentation on how to register a module. ninja_extra : you can provide module string path in INJECTOR_MODULES in NINJA_EXTRA field as shown below: Registering based on Ninja Extra We register modules to INJECTOR_MODULES key in Ninja Extra settings in django settings.py NinjaExtra = { 'INJECTOR_MODULES' : [ 'myproject.app1.modules.SomeModule' , 'myproject.app2.modules.SomeAppModule' , ] } Let's register FileServiceModule module to the NinjaExtra settings, # settings.py ... MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware' , 'django.contrib.sessions.middleware.SessionMiddleware' , 'django.middleware.common.CommonMiddleware' , 'django.middleware.csrf.CsrfViewMiddleware' , 'django.contrib.auth.middleware.AuthenticationMiddleware' , 'django.contrib.messages.middleware.MessageMiddleware' , 'django.middleware.clickjacking.XFrameOptionsMiddleware' , ] NinjaExtra = { 'INJECTOR_MODULES' : [ 'myproject.modules.FileServiceModule' ] } ... That's it. We have completely wired BucketFileUpload service to UserProfileController . Warning You are not only allowed to override your APIController constructor with parameter that don't have annotations Read more Python Injector Using service_resolver The service_resolver is a utility class that help resolves types registered in the injector instance. I could be in handle when we need a service resolved outside controllers. For example: from ninja_extra import service_resolver from .service import BucketFileUpload bucket_service = service_resolver ( BucketFileUpload ) bucket_service . upload_file_to_s3 ( '/path/to/file' ) We can also resolve more than one service at a time and a tuple result will be returned. from ninja_extra import service_resolver from .service import BucketFileUpload bucket_service , service_a , service_b = service_resolver ( BucketFileUpload , AnotherServiceA , AnotherServiceB ) bucket_service . upload_file_to_s3 ( '/path/to/file' ) service_a . do_something () service_b . do_something ()","title":"Dependency Injection"},{"location":"service_module_injector/#dependency-injection","text":"One of the core features of Django Ninja Extra APIController is its support dependency injection using Injector For example, if you have a service called AuthService and you want to use it in your UsersController class, you can simply add it as a parameter in the constructor of the class and annotate it with its type. class UsersController ( ControllerBase ): def __init__ ( self , auth_service : AuthService ): self . auth_service = auth_service Then in your application config, you can register this service and its scope. By default, services are singleton scoped unless specified. def configure ( binder : Binder ) -> Binder : binder . bind ( AuthService , to = AuthServiceImpl , scope = singleton ) You can also specify the scope of the service. This is useful when you want to use different instances of the same service for different requests. def configure ( binder : Binder ) -> Binder : binder . bind ( AuthService , to = AuthServiceImpl , scope = noscope ) In this way, you can easily inject services into your controllers and use them throughout your application. This makes it easy to test your controllers as well as to change the implementation of a service without affecting the rest of the application. Info Django-Ninja-Extra supports django_injector . There is no extra configuration needed.","title":"Dependency Injection"},{"location":"service_module_injector/#creating-a-service","text":"A service refers to a self-contained module or piece of functionality that can be reused across different parts of an application. Services are typically used to encapsulate business logic or to provide access to shared resources, such as databases or external APIs. Services are often implemented as classes, and they can be accessed through an object-oriented interface. Services can be used to perform actions, to interact with external systems, and to perform calculations. They usually have some public methods and properties, which allows other objects to interact with them. Services are usually used to separate the application logic from the infrastructure, this way the application logic can be reused, tested and maintained independently. Let's create a simple S3 bucket service, create a service.py in your project and add the cold below from ninja import File from ninja.files import UploadedFile from ninja_extra import NinjaExtraAPI , api_controller , http_post class BucketFileUploadService : def upload_file_to_s3 ( self , file , bucket_name = None , acl = \"public-read\" , file_key = None ): pass def upload_existing_file_to_s3 ( self , filepath , file_key , bucket_name = None , acl = \"public-read\" , delete_file_afterwards = False , clean_up_root_limit = None ): pass @api_controller ( '/user_profile' ) class UserProfileController : def __init__ ( self , upload_service : BucketFileUploadService ): self . upload_service = upload_service @http_post ( '/upload' ) def upload_profile_pic ( self , file : UploadedFile = File ( ... )): self . upload_service . upload_file_to_s3 ( file = file ) return { 'message' , 'uploaded successfully' } api = NinjaExtraAPI ( title = 'Injector Test' ) api . register_controllers ( UserProfileController )","title":"Creating a Service"},{"location":"service_module_injector/#create-a-module","text":"In Python Injector, a module is a class or a function that is used to configure the dependency injection container. A module is responsible for binding services to their implementations and for configuring the scope of services. A module can define a configure(binder: Binder) function that is used to configure the dependency injection container. The binder argument is an instance of the Binder class that is used to bind services to their implementations. A module can also define one or more provider functions, which are used to create instances of services. These functions can be decorated with @inject to specify the dependencies that they need to be resolved, and they can be decorated with @provider to indicate that they should be used to create instances of services. For example: from injector import Binder , singleton , inject , provider class MyModule : def configure ( self , binder : Binder ) -> Binder : binder . bind ( AuthService , to = AuthServiceImpl , scope = singleton ) @provider @inject def provide_user_service ( self , auth_service : AuthService ) -> UserService : return UserService ( auth_service ) In the example above, MyModule class has configure method which is used to bind the AuthService and set the scope as singleton and provide_user_service which is decorated with @provider and @inject to provide UserService and the AuthService is injected to it as a dependency. By registering a module in Ninja Extra settings, all the services, providers and configurations defined in the module will be added to the Injector, and these services can be resolved and used throughout the application. Lets creates a module for the BucketFileUpload service we created earlier. Create a module.py in your project and add the code below. import logging import os from typing import cast from django.conf import Settings from injector import inject , Module , Binder , singleton logger = logging . getLogger () class InMemoryBucketFileUpload ( BucketFileUpload ): @inject def __init__ ( self , settings : Settings ): logger . info ( f \"===== Using InMemoryBucketFileUpload =======\" ) self . settings = settings assert isinstance ( self . settings , Settings ) def upload_file_to_s3 ( self , file , bucket_name = None , acl = \"public-read\" , file_key = None ): logger . info ( f \"InMemoryBucketFileUpload ---- \" f \"upload_file_to_s3(file= { file . filename } , bucket_name { bucket_name } , acl= { acl } , file_key= { file_key } )\" ) if not file_key : return os . path . join ( self . settings . UPLOAD_FOLDER , file . filename ) return os . path . join ( self . settings . BASE_DIR , file_key ) def upload_existing_file_to_s3 ( self , filepath , file_key , bucket_name = None , acl = \"public-read\" , delete_file_afterwards = False , clean_up_root_limit = None ): logger . info ( f \"InMemoryBucketFileUpload ---- upload_existing_file_to_s3(\" f \"filepath= { filepath } , file_key= { file_key } , \" f \"bucket_name= { bucket_name } , acl= { acl } , delete_file_afterwards= { delete_file_afterwards } )\" ) return filepath class FileServiceModule ( Module ): def configure ( self , binder : Binder ) -> None : binder . bind ( BucketFileUpload , to = InMemoryBucketFileUpload , scope = singleton ) We have created a FileServiceModule that binds BucketFileUpload to InMemoryBucketFileUpload . In our application, when BucketFileUpload is resolved we will get an instance of InMemoryBucketFileUpload provided for us by the injector. We also used inject decorator from injector to inject django settings to InMemoryBucketFileUpload service. The InMemoryBucketFileUpload concrete class is a simple class for development. In production time, you meant want to write a better service to saves file to your AWS S3 bucket.","title":"Create a module"},{"location":"service_module_injector/#service-scope","text":"A scope defines the lifespan of a service created. There are three major scope when working with dependency injection in a web framework","title":"Service Scope"},{"location":"service_module_injector/#singleton-scope","text":"A singleton service is created only once and the same instance is reused for the entire lifetime of the application. This is the default scope when no scope is specified. from injector import Module , Binder , singleton class FileServiceModule ( Module ): def configure ( self , binder : Binder ) -> None : binder . bind ( BucketFileUpload , to = InMemoryBucketFileUpload , scope = singleton )","title":"singleton scope"},{"location":"service_module_injector/#transient-scope","text":"A transient service is created each time it's requested. A new instance is created for each request. This is useful for services that do not maintain state or services that should not be shared across multiple requests. from injector import Module , Binder , noscope class FileServiceModule ( Module ): def configure ( self , binder : Binder ) -> None : binder . bind ( BucketFileUpload , to = InMemoryBucketFileUpload , scope = noscope )","title":"transient scope"},{"location":"service_module_injector/#scoped","text":"A scoped service is created once per request. A new instance is created for each incoming request and is shared among all components that depend on it within the same request. This is useful for services that maintain request-specific state. Currently, Ninja extra does not support scoped scope service. It's important to choose the appropriate scope when registering services with the dependency injection container. Singleton services are suitable for services that maintain application-wide state, transient services are suitable for services that do not maintain state, and scoped services are suitable for services that maintain request-specific state.","title":"scoped"},{"location":"service_module_injector/#adding-service-to-controllers","text":"Ninja Extra controllers constructor ( __init__ ) are decorated with inject function from injector library. This makes it possible define parameter in a parameter in the constructor with a type annotation and the annotated type gets injected during object instantiation. We have created a BucketFileUpload contract and some concrete implementations, lets add it to a controller. Lets create a controller.py with the code below from ninja import File from ninja.files import UploadedFile from ninja_extra import NinjaExtraAPI , api_controller , http_post from .modules import BucketFileUpload , InMemoryBucketFileUpload @api_controller ( '/user_profile' ) class UserProfileController : def __init__ ( self , upload_service : BucketFileUpload ): self . upload_service = upload_service @http_post ( '/upload' ) def upload_profile_pic ( self , file : UploadedFile = File ( ... )): self . upload_service . upload_file_to_s3 ( file = file ) assert isinstance ( self . upload_service , InMemoryBucketFileUpload ) # True return { 'message' , 'uploaded successfully' } api = NinjaExtraAPI ( title = 'Injector Test' ) api . register_controllers ( UserProfileController ) Now, we have defined an BucketFileUpload service dependence to our UserProfileController . We need to register FileServiceModule to settings to avoid getting UnsatisedRequirement exception from injector when Ninja extra tries to create the object.","title":"Adding Service to Controllers"},{"location":"service_module_injector/#module-registration","text":"There are different ways of registering injector Modules in a Django app. django_injector : if you are using django_inject, it has documentation on how to register a module. ninja_extra : you can provide module string path in INJECTOR_MODULES in NINJA_EXTRA field as shown below:","title":"Module Registration"},{"location":"service_module_injector/#registering-based-on-ninja-extra","text":"We register modules to INJECTOR_MODULES key in Ninja Extra settings in django settings.py NinjaExtra = { 'INJECTOR_MODULES' : [ 'myproject.app1.modules.SomeModule' , 'myproject.app2.modules.SomeAppModule' , ] } Let's register FileServiceModule module to the NinjaExtra settings, # settings.py ... MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware' , 'django.contrib.sessions.middleware.SessionMiddleware' , 'django.middleware.common.CommonMiddleware' , 'django.middleware.csrf.CsrfViewMiddleware' , 'django.contrib.auth.middleware.AuthenticationMiddleware' , 'django.contrib.messages.middleware.MessageMiddleware' , 'django.middleware.clickjacking.XFrameOptionsMiddleware' , ] NinjaExtra = { 'INJECTOR_MODULES' : [ 'myproject.modules.FileServiceModule' ] } ... That's it. We have completely wired BucketFileUpload service to UserProfileController . Warning You are not only allowed to override your APIController constructor with parameter that don't have annotations Read more Python Injector","title":"Registering based on Ninja Extra"},{"location":"service_module_injector/#using-service_resolver","text":"The service_resolver is a utility class that help resolves types registered in the injector instance. I could be in handle when we need a service resolved outside controllers. For example: from ninja_extra import service_resolver from .service import BucketFileUpload bucket_service = service_resolver ( BucketFileUpload ) bucket_service . upload_file_to_s3 ( '/path/to/file' ) We can also resolve more than one service at a time and a tuple result will be returned. from ninja_extra import service_resolver from .service import BucketFileUpload bucket_service , service_a , service_b = service_resolver ( BucketFileUpload , AnotherServiceA , AnotherServiceB ) bucket_service . upload_file_to_s3 ( '/path/to/file' ) service_a . do_something () service_b . do_something ()","title":"Using service_resolver"},{"location":"settings/","text":"Settings Django-Ninja-Extra has some settings that can be overridden by adding a NINJA_EXTRA field in Django settings.py with some key-value pair as shown below: # Django project settings.py NINJA_EXTRA = { 'PAGINATION_CLASS' : \"ninja_extra.pagination.PageNumberPaginationExtra\" , 'PAGINATION_PER_PAGE' : 100 , 'INJECTOR_MODULES' : [], 'THROTTLE_CLASSES' : [ \"ninja_extra.throttling.AnonRateThrottle\" , \"ninja_extra.throttling.UserRateThrottle\" , ], 'THROTTLE_RATES' : { 'user' : '1000/day' , 'anon' : '100/day' , }, 'NUM_PROXIES' : None , 'ORDERING_CLASS' : \"ninja_extra.ordering.Ordering\" , 'SEARCHING_CLASS' : \"ninja_extra.searching.Search\" , } You can override what you don't need. It is not necessary need to override everything. PAGINATION_CLASS It defines the default paginator class used by the paginate decorator function if a paginator class is not defined. default: ninja_extra.pagination.LimitOffsetPagination PAGINATION_PER_PAGE It defines the default page size that is passed to the PAGINATION_CLASS during instantiation. default: 100 INJECTOR_MODULES It contains a list of strings that defines the path to injector Module . default: [] THROTTLE_CLASSES It contains a list of strings that defines the path default throttling classes. default: [ \"ninja_extra.throttling.AnonRateThrottle\", \"ninja_extra.throttling.UserRateThrottle\", ] THROTTLE_RATES It contains a key-value pair of different throttling rates which are applies to different THROTTLING_CLASSES . default: { 'user': '1000/day', 'anon': '100/day', } ORDERING_CLASS It defines the default ordering class used by the ordering decorator function if a ordering class is not defined. default: ninja_extra.ordering.Ordering SEARCHING_CLASS It defines the default searching class used by the searching decorator function if a searching class is not defined. default: ninja_extra.searching.Searching","title":"Settings"},{"location":"settings/#settings","text":"Django-Ninja-Extra has some settings that can be overridden by adding a NINJA_EXTRA field in Django settings.py with some key-value pair as shown below: # Django project settings.py NINJA_EXTRA = { 'PAGINATION_CLASS' : \"ninja_extra.pagination.PageNumberPaginationExtra\" , 'PAGINATION_PER_PAGE' : 100 , 'INJECTOR_MODULES' : [], 'THROTTLE_CLASSES' : [ \"ninja_extra.throttling.AnonRateThrottle\" , \"ninja_extra.throttling.UserRateThrottle\" , ], 'THROTTLE_RATES' : { 'user' : '1000/day' , 'anon' : '100/day' , }, 'NUM_PROXIES' : None , 'ORDERING_CLASS' : \"ninja_extra.ordering.Ordering\" , 'SEARCHING_CLASS' : \"ninja_extra.searching.Search\" , } You can override what you don't need. It is not necessary need to override everything.","title":"Settings"},{"location":"settings/#pagination_class","text":"It defines the default paginator class used by the paginate decorator function if a paginator class is not defined. default: ninja_extra.pagination.LimitOffsetPagination","title":"PAGINATION_CLASS"},{"location":"settings/#pagination_per_page","text":"It defines the default page size that is passed to the PAGINATION_CLASS during instantiation. default: 100","title":"PAGINATION_PER_PAGE"},{"location":"settings/#injector_modules","text":"It contains a list of strings that defines the path to injector Module . default: []","title":"INJECTOR_MODULES"},{"location":"settings/#throttle_classes","text":"It contains a list of strings that defines the path default throttling classes. default: [ \"ninja_extra.throttling.AnonRateThrottle\", \"ninja_extra.throttling.UserRateThrottle\", ]","title":"THROTTLE_CLASSES"},{"location":"settings/#throttle_rates","text":"It contains a key-value pair of different throttling rates which are applies to different THROTTLING_CLASSES . default: { 'user': '1000/day', 'anon': '100/day', }","title":"THROTTLE_RATES"},{"location":"settings/#ordering_class","text":"It defines the default ordering class used by the ordering decorator function if a ordering class is not defined. default: ninja_extra.ordering.Ordering","title":"ORDERING_CLASS"},{"location":"settings/#searching_class","text":"It defines the default searching class used by the searching decorator function if a searching class is not defined. default: ninja_extra.searching.Searching","title":"SEARCHING_CLASS"},{"location":"api_controller/","text":"Controller Ninja-Extra APIController is responsible for handling incoming requests and returning responses to the client. In Ninja-Extra, there are major components to creating a controller model ControllerBase APIController Decorator ControllerBase The ControllerBase class is the base class for all controllers in Django Ninja Extra. It provides the core functionality for handling requests, validating input, and returning responses in a class-based approach. The class includes properties and methods that are common to all controllers, such as the request object, permission_classes , and response object which are part of the RouteContext . The request object contains information about the incoming request, such as headers, query parameters, and body data. The permission_classes property is used to define the permissions required to access the controller's routes, while the response object is used to construct the final response that is returned to the client. In addition to the core properties, the ControllerBase class also includes a number of utility methods that can be used to handle common tasks such as object permission checking ( check_object_permission ), creating quick responses ( create_response ), and fetching data from database ( get_object_or_exception ). These methods can be overridden in subclasses to provide custom behavior. The ControllerBase class also includes a dependency injection system that allows for easy access to other services and objects within the application, such as the repository services etc. from ninja_extra import ControllerBase , api_controller @api_controller ( '/users' ) class UserControllerBase ( ControllerBase ): ... APIController Decorator The api_controller decorator is used to define a class-based controller in Django Ninja Extra. It is applied to a ControllerBase class and takes several arguments to configure the routes and functionality of the controller. The first argument, prefix_or_class , is either a prefix string for grouping all routes registered under the controller or the class object that the decorator is applied on. The second argument, auth , is a list of all Django Ninja Auth classes that should be applied to the controller's routes. The third argument, tags , is a list of strings for OPENAPI tags purposes. The fourth argument, permissions , is a list of all permissions that should be applied to the controller's routes. The fifth argument, auto_import , defaults to true, which automatically adds your controller to auto import list. for example: import typing from ninja_extra import api_controller , ControllerBase , permissions , route from django.contrib.auth.models import User from ninja.security import APIKeyQuery from ninja import ModelSchema class UserSchema ( ModelSchema ): class Config : model = User model_fields = [ 'username' , 'email' , 'first_name' ] @api_controller ( 'users/' , auth = [ APIKeyQuery ()], permissions = [ permissions . IsAuthenticated ]) class UsersController ( ControllerBase ): @route . get ( '' , response = { 200 : typing . List [ UserSchema ]}) def get_users ( self ): # Logic to handle GET request to the /users endpoint users = User . objects . all () return users @route . post ( 'create/' , response = { 200 : UserSchema }) def create_user ( self , payload : UserSchema ): # Logic to handle POST request to the /users endpoint new_user = User . objects . create ( username = payload . username , email = payload . email , first_name = payload . first_name , ) new_user . set_password ( 'password' ) return new_user In the above code, we have defined a controller called UsersController using the api_controller decorator. The decorator is applied to the class and takes two arguments, the URL endpoint /users and auth and permission classes. And get_users and create_user are route function that handles GET /users and POST /users/create incoming request. Info Inheriting from ControllerBase class gives you more IDE intellisense support. Quick Example Let's create an APIController to properly manage Django user model import uuid from ninja import ModelSchema from ninja_extra import ( http_get , http_post , http_generic , http_delete , api_controller , status , ControllerBase , pagination ) from ninja_extra.controllers.response import Detail from django.contrib.auth import get_user_model class UserSchema ( ModelSchema ): class Config : model = get_user_model () model_fields = [ 'username' , 'email' , 'first_name' ] @api_controller ( '/users' ) class UsersController ( ControllerBase ): user_model = get_user_model () @http_post () def create_user ( self , user : UserSchema ): # just simulating created user return self . Id ( uuid . uuid4 ()) @http_generic ( '/{int:user_id}' , methods = [ 'put' , 'patch' ], response = UserSchema ) def update_user ( self , user_id : int ): \"\"\" Django Ninja will serialize Django ORM model to schema provided as `response`\"\"\" user = self . get_object_or_exception ( self . user_model , id = user_id ) return user @http_delete ( '/{int:user_id}' , response = Detail ( status_code = status . HTTP_204_NO_CONTENT )) def delete_user ( self , user_id : int ): user = self . get_object_or_exception ( self . user_model , id = user_id ) user . delete () return self . create_response ( '' , status_code = status . HTTP_204_NO_CONTENT ) @http_get ( \"\" , response = pagination . PaginatedResponseSchema [ UserSchema ]) @pagination . paginate ( pagination . PageNumberPaginationExtra , page_size = 50 ) def list_user ( self ): return self . user_model . objects . all () @http_get ( '/ {user_id} ' , response = UserSchema ) def get_user_by_id ( self , user_id : int ): user = self . get_object_or_exception ( self . user_model , id = user_id ) return user In the example above, the UsersController class defines several methods that correspond to different HTTP methods, such as create_user , update_user , delete_user , list_user and get_user_by_id . These methods are decorated with http_post , http_generic , http_delete , http_get decorators respectively. The create_user method uses http_post decorator and accepts a user argument of type UserSchema , which is a ModelSchema that is used to validate and serialize the input data. The method is used to create a new user in the system and return an ID of the user. The update_user method uses http_generic decorator and accepts a user_id argument of type int. The decorator is configured to handle both PUT and PATCH methods and provides a response argument of type UserSchema which will be used to serialize the user object. The delete_user method uses http_delete decorator and accepts a user_id argument of type int and a response argument of type Detail which will be used to return a 204 status code with an empty body on success. The list_user method uses http_get decorator and decorated with pagination.paginate decorator that paginate the results of the method using PageNumberPaginationExtra class with page_size=50. It also provides a response argument of type pagination.PaginatedResponseSchema[UserSchema] which will be used to serialize and paginate the list of users returned by the method. The get_user_by_id method uses http_get decorator and accepts a user_id argument of type int and a response argument of type UserSchema which will be used to serialize the user object. The UsersController also use self.get_object_or_exception(self.user_model, id=user_id) which is a helper method that will raise an exception if the user object is not found.","title":"Index"},{"location":"api_controller/#controller","text":"Ninja-Extra APIController is responsible for handling incoming requests and returning responses to the client. In Ninja-Extra, there are major components to creating a controller model ControllerBase APIController Decorator","title":"Controller"},{"location":"api_controller/#controllerbase","text":"The ControllerBase class is the base class for all controllers in Django Ninja Extra. It provides the core functionality for handling requests, validating input, and returning responses in a class-based approach. The class includes properties and methods that are common to all controllers, such as the request object, permission_classes , and response object which are part of the RouteContext . The request object contains information about the incoming request, such as headers, query parameters, and body data. The permission_classes property is used to define the permissions required to access the controller's routes, while the response object is used to construct the final response that is returned to the client. In addition to the core properties, the ControllerBase class also includes a number of utility methods that can be used to handle common tasks such as object permission checking ( check_object_permission ), creating quick responses ( create_response ), and fetching data from database ( get_object_or_exception ). These methods can be overridden in subclasses to provide custom behavior. The ControllerBase class also includes a dependency injection system that allows for easy access to other services and objects within the application, such as the repository services etc. from ninja_extra import ControllerBase , api_controller @api_controller ( '/users' ) class UserControllerBase ( ControllerBase ): ...","title":"ControllerBase"},{"location":"api_controller/#apicontroller-decorator","text":"The api_controller decorator is used to define a class-based controller in Django Ninja Extra. It is applied to a ControllerBase class and takes several arguments to configure the routes and functionality of the controller. The first argument, prefix_or_class , is either a prefix string for grouping all routes registered under the controller or the class object that the decorator is applied on. The second argument, auth , is a list of all Django Ninja Auth classes that should be applied to the controller's routes. The third argument, tags , is a list of strings for OPENAPI tags purposes. The fourth argument, permissions , is a list of all permissions that should be applied to the controller's routes. The fifth argument, auto_import , defaults to true, which automatically adds your controller to auto import list. for example: import typing from ninja_extra import api_controller , ControllerBase , permissions , route from django.contrib.auth.models import User from ninja.security import APIKeyQuery from ninja import ModelSchema class UserSchema ( ModelSchema ): class Config : model = User model_fields = [ 'username' , 'email' , 'first_name' ] @api_controller ( 'users/' , auth = [ APIKeyQuery ()], permissions = [ permissions . IsAuthenticated ]) class UsersController ( ControllerBase ): @route . get ( '' , response = { 200 : typing . List [ UserSchema ]}) def get_users ( self ): # Logic to handle GET request to the /users endpoint users = User . objects . all () return users @route . post ( 'create/' , response = { 200 : UserSchema }) def create_user ( self , payload : UserSchema ): # Logic to handle POST request to the /users endpoint new_user = User . objects . create ( username = payload . username , email = payload . email , first_name = payload . first_name , ) new_user . set_password ( 'password' ) return new_user In the above code, we have defined a controller called UsersController using the api_controller decorator. The decorator is applied to the class and takes two arguments, the URL endpoint /users and auth and permission classes. And get_users and create_user are route function that handles GET /users and POST /users/create incoming request. Info Inheriting from ControllerBase class gives you more IDE intellisense support.","title":"APIController Decorator"},{"location":"api_controller/#quick-example","text":"Let's create an APIController to properly manage Django user model import uuid from ninja import ModelSchema from ninja_extra import ( http_get , http_post , http_generic , http_delete , api_controller , status , ControllerBase , pagination ) from ninja_extra.controllers.response import Detail from django.contrib.auth import get_user_model class UserSchema ( ModelSchema ): class Config : model = get_user_model () model_fields = [ 'username' , 'email' , 'first_name' ] @api_controller ( '/users' ) class UsersController ( ControllerBase ): user_model = get_user_model () @http_post () def create_user ( self , user : UserSchema ): # just simulating created user return self . Id ( uuid . uuid4 ()) @http_generic ( '/{int:user_id}' , methods = [ 'put' , 'patch' ], response = UserSchema ) def update_user ( self , user_id : int ): \"\"\" Django Ninja will serialize Django ORM model to schema provided as `response`\"\"\" user = self . get_object_or_exception ( self . user_model , id = user_id ) return user @http_delete ( '/{int:user_id}' , response = Detail ( status_code = status . HTTP_204_NO_CONTENT )) def delete_user ( self , user_id : int ): user = self . get_object_or_exception ( self . user_model , id = user_id ) user . delete () return self . create_response ( '' , status_code = status . HTTP_204_NO_CONTENT ) @http_get ( \"\" , response = pagination . PaginatedResponseSchema [ UserSchema ]) @pagination . paginate ( pagination . PageNumberPaginationExtra , page_size = 50 ) def list_user ( self ): return self . user_model . objects . all () @http_get ( '/ {user_id} ' , response = UserSchema ) def get_user_by_id ( self , user_id : int ): user = self . get_object_or_exception ( self . user_model , id = user_id ) return user In the example above, the UsersController class defines several methods that correspond to different HTTP methods, such as create_user , update_user , delete_user , list_user and get_user_by_id . These methods are decorated with http_post , http_generic , http_delete , http_get decorators respectively. The create_user method uses http_post decorator and accepts a user argument of type UserSchema , which is a ModelSchema that is used to validate and serialize the input data. The method is used to create a new user in the system and return an ID of the user. The update_user method uses http_generic decorator and accepts a user_id argument of type int. The decorator is configured to handle both PUT and PATCH methods and provides a response argument of type UserSchema which will be used to serialize the user object. The delete_user method uses http_delete decorator and accepts a user_id argument of type int and a response argument of type Detail which will be used to return a 204 status code with an empty body on success. The list_user method uses http_get decorator and decorated with pagination.paginate decorator that paginate the results of the method using PageNumberPaginationExtra class with page_size=50. It also provides a response argument of type pagination.PaginatedResponseSchema[UserSchema] which will be used to serialize and paginate the list of users returned by the method. The get_user_by_id method uses http_get decorator and accepts a user_id argument of type int and a response argument of type UserSchema which will be used to serialize the user object. The UsersController also use self.get_object_or_exception(self.user_model, id=user_id) which is a helper method that will raise an exception if the user object is not found.","title":"Quick Example"},{"location":"api_controller/api_controller_permission/","text":"APIController Permissions The concept of this permission system came from Django DRF . Permission checks are always run at the very start of the route function, before any other code is allowed to proceed. Permission checks will typically use the authentication information in the request.user and request.auth properties to determine if the incoming request should be permitted. Permissions are used to grant or deny access for different classes of users to different parts of the API. The simplest style of permission would be to allow access to any authenticated user, and deny access to any unauthenticated user. This corresponds to the IsAuthenticated class in Django Ninja Extra . A slightly less strict style of permission would be to allow full access to authenticated users, but allow read-only access to unauthenticated users. This corresponds to the IsAuthenticatedOrReadOnly class in Django Ninja Extra . Limitations of object level permissions During route function call, we can only has_permission in permissions list are called automatic. But since we don't have the object, we can only invoke has_object_permission if you use get_object_or_exception or get_object_or_none methods which are available to APIController. Custom permissions To implement a custom permission, override BasePermission and implement either, or both, of the following methods: .has_permission ( self , request : HttpRequest , controller : \"APIController\" ) .has_object_permission ( self , request : HttpRequest , controller : \"APIController\" , obj : Any ) Example from ninja_extra import permissions , api_controller , http_get class ReadOnly ( permissions . BasePermission ): def has_permission ( self , request , view ): return request . method in permissions . SAFE_METHODS @api_controller ( permissions = [ permissions . IsAuthenticated | ReadOnly ]) class PermissionController : @http_get ( '/must_be_authenticated' , permissions = [ permissions . IsAuthenticated ]) def must_be_authenticated ( self , word : str ): return dict ( says = word ) Note New in v0.18.7 Controller Permission and Route Function permissions can now take BasePermission instance. For example, we can pass the ReadOnly instance to the permission parameter. from ninja_extra import permissions , api_controller , http_get class ReadOnly ( permissions . BasePermission ): def has_permission ( self , request , view ): return request . method in permissions . SAFE_METHODS @api_controller ( permissions = [ permissions . IsAuthenticated | ReadOnly ()]) ... For example: from ninja_extra import permissions class UserWithPermission ( permissions . BasePermission ): def __init__ ( self , permission : str ) -> None : self . _permission = permission def has_permission ( self , request , view ): return request . user . has_perm ( self . _permission ) # in controller or route function permissions = [ UserWithPermission ( 'blog.add' )] Permissions Supported Operands & (and) eg: permissions.IsAuthenticated & ReadOnly | (or) eg: permissions.IsAuthenticated | ReadOnly ~ (not) eg: ~(permissions.IsAuthenticated & ReadOnly)","title":"Controller Permissions"},{"location":"api_controller/api_controller_permission/#apicontroller-permissions","text":"The concept of this permission system came from Django DRF . Permission checks are always run at the very start of the route function, before any other code is allowed to proceed. Permission checks will typically use the authentication information in the request.user and request.auth properties to determine if the incoming request should be permitted. Permissions are used to grant or deny access for different classes of users to different parts of the API. The simplest style of permission would be to allow access to any authenticated user, and deny access to any unauthenticated user. This corresponds to the IsAuthenticated class in Django Ninja Extra . A slightly less strict style of permission would be to allow full access to authenticated users, but allow read-only access to unauthenticated users. This corresponds to the IsAuthenticatedOrReadOnly class in Django Ninja Extra .","title":"APIController Permissions"},{"location":"api_controller/api_controller_permission/#limitations-of-object-level-permissions","text":"During route function call, we can only has_permission in permissions list are called automatic. But since we don't have the object, we can only invoke has_object_permission if you use get_object_or_exception or get_object_or_none methods which are available to APIController.","title":"Limitations of object level permissions"},{"location":"api_controller/api_controller_permission/#custom-permissions","text":"To implement a custom permission, override BasePermission and implement either, or both, of the following methods: .has_permission ( self , request : HttpRequest , controller : \"APIController\" ) .has_object_permission ( self , request : HttpRequest , controller : \"APIController\" , obj : Any ) Example from ninja_extra import permissions , api_controller , http_get class ReadOnly ( permissions . BasePermission ): def has_permission ( self , request , view ): return request . method in permissions . SAFE_METHODS @api_controller ( permissions = [ permissions . IsAuthenticated | ReadOnly ]) class PermissionController : @http_get ( '/must_be_authenticated' , permissions = [ permissions . IsAuthenticated ]) def must_be_authenticated ( self , word : str ): return dict ( says = word ) Note New in v0.18.7 Controller Permission and Route Function permissions can now take BasePermission instance. For example, we can pass the ReadOnly instance to the permission parameter. from ninja_extra import permissions , api_controller , http_get class ReadOnly ( permissions . BasePermission ): def has_permission ( self , request , view ): return request . method in permissions . SAFE_METHODS @api_controller ( permissions = [ permissions . IsAuthenticated | ReadOnly ()]) ... For example: from ninja_extra import permissions class UserWithPermission ( permissions . BasePermission ): def __init__ ( self , permission : str ) -> None : self . _permission = permission def has_permission ( self , request , view ): return request . user . has_perm ( self . _permission ) # in controller or route function permissions = [ UserWithPermission ( 'blog.add' )]","title":"Custom permissions"},{"location":"api_controller/api_controller_permission/#permissions-supported-operands","text":"& (and) eg: permissions.IsAuthenticated & ReadOnly | (or) eg: permissions.IsAuthenticated | ReadOnly ~ (not) eg: ~(permissions.IsAuthenticated & ReadOnly)","title":"Permissions Supported Operands"},{"location":"api_controller/api_controller_route/","text":"APIController Route Decorator The route class is a function decorator, used to mark an instance function of an APIController class, as an endpoint. Info ControllerRoute or route is not the same with django-ninja router and can't be used interchangeably. For example from ninja_extra import route , api_controller from ninja_extra.controllers import RouteFunction @api_controller class MyController : @route . get ( '/test' ) def test ( self ): return { 'message' : 'test' } assert isinstance ( MyController . test , RouteFunction ) # true The route has predefined method that helps create the following operations and their names proceeds its operation GET POST PUT DELETE PATCH GENERIC-for operation combination eg: methods=['POST', 'PATCH'] Initialization Parameters path it's a required uniques endpoint path string methods it's required a collection of endpoint operational mode eg: ['POST', 'PUT'] auth defines endpoint authentication method. default: NOT_SET response defines dict[status_code, schema] or Schema . It is used validated returned response. default: NOT_SET operation_id it is an optional unique id that distinguishes operations in path view. default: NOT_SET summary it is an optional summary that describes your endpoint. default: None description it is an optional description that describes your endpoint. default: None tags It is a list of strings useful for endpoint grouping for documentation purpose. default: None deprecated it is an optional boolean parameter that declares an endpoint deprecated. default: None by_alias it is an optional parameter that is applied to filter response schema object. default: False exclude_unset it is an optional parameter that is applied to filter response schema object. default: False exclude_defaults it is an optional parameter that is applied to filter response schema object. default: False exclude_none it is an optional parameter that is applied to filter response schema object. default: False include_in_schema indicates whether an endpoint should appear on the swagger documentation. default: True url_name it gives a name to an endpoint which can be resolved using reverse function in django. default: None permissions defines collection route permission classes. default: None Most of these parameters are what is used in creating and endpoint in Django-Ninja, but it has been abstracted here to be for the same purpose on APIController class Async Route Definition Django-Ninja-Extra route class also supports async endpoint definition just like in Django-Ninja. This is only available on Django > 3.0. For Example import asyncio from ninja_extra import http_get , api_controller from ninja_extra.controllers import AsyncRouteFunction @api_controller class MyController : @http_get ( \"/say-after\" ) async def say_after ( self , delay : int , word : str ): await asyncio . sleep ( delay ) return { 'saying' : word } assert isinstance ( MyController . say_after , AsyncRouteFunction ) # true Info Read more on Django-Ninja Async Support","title":"Controller Routes"},{"location":"api_controller/api_controller_route/#apicontroller-route-decorator","text":"The route class is a function decorator, used to mark an instance function of an APIController class, as an endpoint. Info ControllerRoute or route is not the same with django-ninja router and can't be used interchangeably. For example from ninja_extra import route , api_controller from ninja_extra.controllers import RouteFunction @api_controller class MyController : @route . get ( '/test' ) def test ( self ): return { 'message' : 'test' } assert isinstance ( MyController . test , RouteFunction ) # true The route has predefined method that helps create the following operations and their names proceeds its operation GET POST PUT DELETE PATCH GENERIC-for operation combination eg: methods=['POST', 'PATCH']","title":"APIController Route Decorator"},{"location":"api_controller/api_controller_route/#initialization-parameters","text":"","title":"Initialization Parameters"},{"location":"api_controller/api_controller_route/#path","text":"it's a required uniques endpoint path string","title":"path"},{"location":"api_controller/api_controller_route/#methods","text":"it's required a collection of endpoint operational mode eg: ['POST', 'PUT']","title":"methods"},{"location":"api_controller/api_controller_route/#auth","text":"defines endpoint authentication method. default: NOT_SET","title":"auth"},{"location":"api_controller/api_controller_route/#response","text":"defines dict[status_code, schema] or Schema . It is used validated returned response. default: NOT_SET","title":"response"},{"location":"api_controller/api_controller_route/#operation_id","text":"it is an optional unique id that distinguishes operations in path view. default: NOT_SET","title":"operation_id"},{"location":"api_controller/api_controller_route/#summary","text":"it is an optional summary that describes your endpoint. default: None","title":"summary"},{"location":"api_controller/api_controller_route/#description","text":"it is an optional description that describes your endpoint. default: None","title":"description"},{"location":"api_controller/api_controller_route/#tags","text":"It is a list of strings useful for endpoint grouping for documentation purpose. default: None","title":"tags"},{"location":"api_controller/api_controller_route/#deprecated","text":"it is an optional boolean parameter that declares an endpoint deprecated. default: None","title":"deprecated"},{"location":"api_controller/api_controller_route/#by_alias","text":"it is an optional parameter that is applied to filter response schema object. default: False","title":"by_alias"},{"location":"api_controller/api_controller_route/#exclude_unset","text":"it is an optional parameter that is applied to filter response schema object. default: False","title":"exclude_unset"},{"location":"api_controller/api_controller_route/#exclude_defaults","text":"it is an optional parameter that is applied to filter response schema object. default: False","title":"exclude_defaults"},{"location":"api_controller/api_controller_route/#exclude_none","text":"it is an optional parameter that is applied to filter response schema object. default: False","title":"exclude_none"},{"location":"api_controller/api_controller_route/#include_in_schema","text":"indicates whether an endpoint should appear on the swagger documentation. default: True","title":"include_in_schema"},{"location":"api_controller/api_controller_route/#url_name","text":"it gives a name to an endpoint which can be resolved using reverse function in django. default: None","title":"url_name"},{"location":"api_controller/api_controller_route/#permissions","text":"defines collection route permission classes. default: None Most of these parameters are what is used in creating and endpoint in Django-Ninja, but it has been abstracted here to be for the same purpose on APIController class","title":"permissions"},{"location":"api_controller/api_controller_route/#async-route-definition","text":"Django-Ninja-Extra route class also supports async endpoint definition just like in Django-Ninja. This is only available on Django > 3.0. For Example import asyncio from ninja_extra import http_get , api_controller from ninja_extra.controllers import AsyncRouteFunction @api_controller class MyController : @http_get ( \"/say-after\" ) async def say_after ( self , delay : int , word : str ): await asyncio . sleep ( delay ) return { 'saying' : word } assert isinstance ( MyController . say_after , AsyncRouteFunction ) # true Info Read more on Django-Ninja Async Support","title":"Async Route Definition"},{"location":"api_controller/api_controller_router/","text":"APIController Router The ControllerRouter is router in short form, is an adapter class that adapts APIController classes to Django-Ninja router . During api.register_controllers call, the APIController _router is passed to the Django-Ninja for route processing. For this reason, APIController class can't be registered without having a ControllerRouter class decoration Controller Router Initialization Parameters prefix it is a required parameter that defines extra route prefix for all route functions defined in an APIController class auth It is an optional parameter that defines global auth for APIController classes. This can be overridden by route auth definition. default: NOT_SET tags It is an optional parameter that defines global tags for APIController classes. This can be overridden by route tags definition. default: None permissions It is an optional parameter that defines global permissions APIController classes. This can be overridden by route permissions definition. default: None controller: Optional[Type[\"APIController\"]] It is APIController class decorated Quick Usage from ninja.constants import NOT_SET from ninja_extra import APIController , router , NinjaExtraAPI router = router ( prefix = '' , auth = NOT_SET , tags = [ 'someTags' ], permissions = []) @router class MyRouterController ( APIController ): '''testing''' api = NinjaExtraAPI () api . register_controllers ( MyRouterController )","title":"**APIController Router**"},{"location":"api_controller/api_controller_router/#apicontroller-router","text":"The ControllerRouter is router in short form, is an adapter class that adapts APIController classes to Django-Ninja router . During api.register_controllers call, the APIController _router is passed to the Django-Ninja for route processing. For this reason, APIController class can't be registered without having a ControllerRouter class decoration","title":"APIController Router"},{"location":"api_controller/api_controller_router/#controller-router-initialization-parameters","text":"","title":"Controller Router Initialization Parameters"},{"location":"api_controller/api_controller_router/#prefix","text":"it is a required parameter that defines extra route prefix for all route functions defined in an APIController class","title":"prefix"},{"location":"api_controller/api_controller_router/#auth","text":"It is an optional parameter that defines global auth for APIController classes. This can be overridden by route auth definition. default: NOT_SET","title":"auth"},{"location":"api_controller/api_controller_router/#tags","text":"It is an optional parameter that defines global tags for APIController classes. This can be overridden by route tags definition. default: None","title":"tags"},{"location":"api_controller/api_controller_router/#permissions","text":"It is an optional parameter that defines global permissions APIController classes. This can be overridden by route permissions definition. default: None","title":"permissions"},{"location":"api_controller/api_controller_router/#controller-optionaltypeapicontroller","text":"It is APIController class decorated","title":"controller: Optional[Type[\"APIController\"]]"},{"location":"api_controller/api_controller_router/#quick-usage","text":"from ninja.constants import NOT_SET from ninja_extra import APIController , router , NinjaExtraAPI router = router ( prefix = '' , auth = NOT_SET , tags = [ 'someTags' ], permissions = []) @router class MyRouterController ( APIController ): '''testing''' api = NinjaExtraAPI () api . register_controllers ( MyRouterController )","title":"Quick Usage"},{"location":"tutorial/","text":"Tutorial / Reference This tutorial shows you how to use Django Ninja Extra with most of its features. And most especially assumes you know how to use Django Ninja Info A lot of content here is drawn from Django-Ninja. So a lot would make sense if you understand the Django-Ninja framework first. Installation pip install django-ninja-extra After installation, add ninja_extra to your INSTALLED_APPS INSTALLED_APPS = [ ... , 'ninja_extra' , ] Create a Django project (If you already have an existing Django project, skip to the next step). Start a new Django project (or use an existing one). django-admin startproject myproject First steps Let's create a module for our API. Create an api.py file in the same directory location as urls.py : api.py from ninja_extra import NinjaExtraAPI api = NinjaExtraAPI () # function definition using Django-Ninja default router @api . get ( \"/hello\" ) def hello ( request ): return \"Hello world\" Now go to urls.py and add the following: from django.contrib import admin from django.urls import path from .api import api urlpatterns = [ path ( \"admin/\" , admin . site . urls ), path ( \"api/\" , api . urls ), ] Defining operation methods \"Operation\" can be one of the HTTP \"methods\": GET POST PUT DELETE PATCH ... and more. These are Django-Ninja defined operations on the API or Django-Ninja router. The same operation is exposed to APIControllers with the route class. The route class is an extra decorator that converts APIController instance methods to route function or endpoint. On the other hand, the router here is a short form of the ControllerRouter class, an adapter class, which is an that only adapts APIController to the Django-Ninja router. It also provides global control of all routes defined in any APIController class. from ninja_extra import ( api_controller , http_get , http_post , http_put , http_delete , http_patch , http_generic ) from ninja.constants import NOT_SET @api_controller ( '' , tags = [ 'My Operations' ], auth = NOT_SET , permissions = []) class MyAPIController : @http_get ( \"/path\" ) def get_operation ( self ): ... @http_post ( \"/path\" ) def post_operation ( self ): ... @http_put ( \"/path\" ) def put_operation ( self ): ... @http_delete ( \"/path\" ) def delete_operation ( self ): ... @http_patch ( \"/path\" ) def patch_operation ( self ): ... # If you need to handle multiple methods with a single function, you can use the `generic` method as shown above @http_generic ([ \"POST\" , \"PATCH\" ]) def mixed ( request ): ... api . register_controllers ( MyAPIController ) To have a complete Controller setup, the APIController must be decorated with ControllerRouter before it's been registered.","title":"Quick Tutorial"},{"location":"tutorial/#tutorial-reference","text":"This tutorial shows you how to use Django Ninja Extra with most of its features. And most especially assumes you know how to use Django Ninja Info A lot of content here is drawn from Django-Ninja. So a lot would make sense if you understand the Django-Ninja framework first.","title":"Tutorial / Reference"},{"location":"tutorial/#installation","text":"pip install django-ninja-extra After installation, add ninja_extra to your INSTALLED_APPS INSTALLED_APPS = [ ... , 'ninja_extra' , ]","title":"Installation"},{"location":"tutorial/#create-a-django-project","text":"(If you already have an existing Django project, skip to the next step). Start a new Django project (or use an existing one). django-admin startproject myproject","title":"Create a Django project"},{"location":"tutorial/#first-steps","text":"Let's create a module for our API. Create an api.py file in the same directory location as urls.py : api.py from ninja_extra import NinjaExtraAPI api = NinjaExtraAPI () # function definition using Django-Ninja default router @api . get ( \"/hello\" ) def hello ( request ): return \"Hello world\" Now go to urls.py and add the following: from django.contrib import admin from django.urls import path from .api import api urlpatterns = [ path ( \"admin/\" , admin . site . urls ), path ( \"api/\" , api . urls ), ]","title":"First steps"},{"location":"tutorial/#defining-operation-methods","text":"\"Operation\" can be one of the HTTP \"methods\": GET POST PUT DELETE PATCH ... and more. These are Django-Ninja defined operations on the API or Django-Ninja router. The same operation is exposed to APIControllers with the route class. The route class is an extra decorator that converts APIController instance methods to route function or endpoint. On the other hand, the router here is a short form of the ControllerRouter class, an adapter class, which is an that only adapts APIController to the Django-Ninja router. It also provides global control of all routes defined in any APIController class. from ninja_extra import ( api_controller , http_get , http_post , http_put , http_delete , http_patch , http_generic ) from ninja.constants import NOT_SET @api_controller ( '' , tags = [ 'My Operations' ], auth = NOT_SET , permissions = []) class MyAPIController : @http_get ( \"/path\" ) def get_operation ( self ): ... @http_post ( \"/path\" ) def post_operation ( self ): ... @http_put ( \"/path\" ) def put_operation ( self ): ... @http_delete ( \"/path\" ) def delete_operation ( self ): ... @http_patch ( \"/path\" ) def patch_operation ( self ): ... # If you need to handle multiple methods with a single function, you can use the `generic` method as shown above @http_generic ([ \"POST\" , \"PATCH\" ]) def mixed ( request ): ... api . register_controllers ( MyAPIController ) To have a complete Controller setup, the APIController must be decorated with ControllerRouter before it's been registered.","title":"Defining operation methods"},{"location":"tutorial/authentication/","text":"Authentication Django Ninja Extra offers the same API for authorization and authentication as in Django Ninja , ensuring consistency and ease of use across both packages. Automatic OpenAPI schema Here's an example where the client, in order to authenticate, needs to pass a header: Authorization: Bearer supersecret from ninja.security import HttpBearer from ninja_extra import api_controller , route from ninja.constants import NOT_SET class AuthBearer ( HttpBearer ): def authenticate ( self , request , token ): if token == \"supersecret\" : return token @api_controller ( tags = [ 'My Operations' ], auth = NOT_SET , permissions = []) class MyController : @route . get ( \"/bearer\" , auth = AuthBearer ()) def bearer ( self ): return { \"token\" : self . request . auth } Global authentication In case you need to secure all route methods defined in api and APIController, you can pass the auth argument to the NinjaExtraAPI constructor: from ninja_extra import NinjaExtraAPI from ninja.security import HttpBearer class GlobalAuth ( HttpBearer ): def authenticate ( self , request , token ): if token == \"supersecret\" : return token api = NinjaExtraAPI ( auth = GlobalAuth ()) Read more on django-ninja authentication Asynchronous Auth Classes Ninja Extra added Asynchronous support for all Auth base classes provided by Django Ninja in ninja_extra.security package. And it maintained similar interface. It is important to noted that when using these asynchronous auth classes, the endpoint handler must asynchronous functions. For example, lets re-write the first auth example with AsyncHttpBearer class. from ninja_extra import api_controller , route from ninja_extra.security import AsyncHttpBearer from ninja.constants import NOT_SET class AuthBearer ( AsyncHttpBearer ): async def authenticate ( self , request , token ): # await some actions if token == \"supersecret\" : return token @api_controller ( tags = [ 'My Operations' ], auth = NOT_SET , permissions = []) class MyController : @route . get ( \"/bearer\" , auth = AuthBearer ()) async def bearer ( self ): return { \"token\" : self . request . auth } In example above, we changed HttpBearer to AsyncHttpBearer and changed bearer to async endpoint. If AuthBearer is to be applied to a MyController auth , then all route handlers under MyController must be asynchronous route handlers. JWT Authentication if you want to use JWT authentication. See ninja-jwt","title":"Authentication"},{"location":"tutorial/authentication/#authentication","text":"Django Ninja Extra offers the same API for authorization and authentication as in Django Ninja , ensuring consistency and ease of use across both packages.","title":"Authentication"},{"location":"tutorial/authentication/#automatic-openapi-schema","text":"Here's an example where the client, in order to authenticate, needs to pass a header: Authorization: Bearer supersecret from ninja.security import HttpBearer from ninja_extra import api_controller , route from ninja.constants import NOT_SET class AuthBearer ( HttpBearer ): def authenticate ( self , request , token ): if token == \"supersecret\" : return token @api_controller ( tags = [ 'My Operations' ], auth = NOT_SET , permissions = []) class MyController : @route . get ( \"/bearer\" , auth = AuthBearer ()) def bearer ( self ): return { \"token\" : self . request . auth }","title":"Automatic OpenAPI schema"},{"location":"tutorial/authentication/#global-authentication","text":"In case you need to secure all route methods defined in api and APIController, you can pass the auth argument to the NinjaExtraAPI constructor: from ninja_extra import NinjaExtraAPI from ninja.security import HttpBearer class GlobalAuth ( HttpBearer ): def authenticate ( self , request , token ): if token == \"supersecret\" : return token api = NinjaExtraAPI ( auth = GlobalAuth ()) Read more on django-ninja authentication","title":"Global authentication"},{"location":"tutorial/authentication/#asynchronous-auth-classes","text":"Ninja Extra added Asynchronous support for all Auth base classes provided by Django Ninja in ninja_extra.security package. And it maintained similar interface. It is important to noted that when using these asynchronous auth classes, the endpoint handler must asynchronous functions. For example, lets re-write the first auth example with AsyncHttpBearer class. from ninja_extra import api_controller , route from ninja_extra.security import AsyncHttpBearer from ninja.constants import NOT_SET class AuthBearer ( AsyncHttpBearer ): async def authenticate ( self , request , token ): # await some actions if token == \"supersecret\" : return token @api_controller ( tags = [ 'My Operations' ], auth = NOT_SET , permissions = []) class MyController : @route . get ( \"/bearer\" , auth = AuthBearer ()) async def bearer ( self ): return { \"token\" : self . request . auth } In example above, we changed HttpBearer to AsyncHttpBearer and changed bearer to async endpoint. If AuthBearer is to be applied to a MyController auth , then all route handlers under MyController must be asynchronous route handlers.","title":"Asynchronous Auth Classes"},{"location":"tutorial/authentication/#jwt-authentication","text":"if you want to use JWT authentication. See ninja-jwt","title":"JWT Authentication"},{"location":"tutorial/body_request/","text":"Request Body Request bodies are typically used with \u201ccreate\u201d and \u201cupdate\u201d operations (POST, PUT, PATCH). For example, when creating a resource using POST or PUT, the request body usually contains the representation of the resource to be created. To declare a request body , you need to use Django Ninja Schema or any Pydantic Schema that suits your need. I recommend Ninja-Schema Create your data model Then you declare your data model as a class that inherits from Schema . Use standard Python types for all the attributes: from ninja import Schema , constants from ninja_extra import api_controller , route class Item ( Schema ): name : str description : str = None price : float quantity : int @api_controller ( tags = [ 'My Operations' ], auth = constants . NOT_SET , permissions = []) class MyAPIController : @route . post ( \"/items\" ) def create ( self , item : Item ): return item Note: if you use None as the default value for an attribute, it will become optional in the request body. For example, this model above declares a JSON \" object \" (or Python dict ) like: { \"name\" : \"Katana\" , \"description\" : \"An optional description\" , \"price\" : 299.00 , \"quantity\" : 10 } ...as description is optional (with a default value of None ), this JSON \" object \" would also be valid: { \"name\" : \"Katana\" , \"price\" : 299.00 , \"quantity\" : 10 }","title":"Body Request"},{"location":"tutorial/body_request/#request-body","text":"Request bodies are typically used with \u201ccreate\u201d and \u201cupdate\u201d operations (POST, PUT, PATCH). For example, when creating a resource using POST or PUT, the request body usually contains the representation of the resource to be created. To declare a request body , you need to use Django Ninja Schema or any Pydantic Schema that suits your need. I recommend Ninja-Schema","title":"Request Body"},{"location":"tutorial/body_request/#create-your-data-model","text":"Then you declare your data model as a class that inherits from Schema . Use standard Python types for all the attributes: from ninja import Schema , constants from ninja_extra import api_controller , route class Item ( Schema ): name : str description : str = None price : float quantity : int @api_controller ( tags = [ 'My Operations' ], auth = constants . NOT_SET , permissions = []) class MyAPIController : @route . post ( \"/items\" ) def create ( self , item : Item ): return item Note: if you use None as the default value for an attribute, it will become optional in the request body. For example, this model above declares a JSON \" object \" (or Python dict ) like: { \"name\" : \"Katana\" , \"description\" : \"An optional description\" , \"price\" : 299.00 , \"quantity\" : 10 } ...as description is optional (with a default value of None ), this JSON \" object \" would also be valid: { \"name\" : \"Katana\" , \"price\" : 299.00 , \"quantity\" : 10 }","title":"Create your data model"},{"location":"tutorial/custom_exception/","text":"Custom Exception Django-Ninja provides an intuitive way of handling custom exceptions by registering a function(handler) against an Exception type, just like it's done in a Flask app. So in that sense, Django-Ninja-Extra has an APIException exception type which provides similar functionalities, for those use to DRF APIException . For Example: from ninja_extra.exceptions import APIException from ninja_extra import api_controller , route , NinjaExtraAPI , status from ninja import constants class CustomAPIException ( APIException ): status_code = status . HTTP_401_UNAUTHORIZED message = 'UnAuthorized' @api_controller ( '' , tags = [ 'My Operations' ], auth = constants . NOT_SET , permissions = []) class MyController : @route . get ( '/exception' ) def custom_exception ( self ): raise CustomAPIException () api = NinjaExtraAPI ( title = 'Exception Test' ) api . register_controllers ( MyController )","title":"Error Handling"},{"location":"tutorial/custom_exception/#custom-exception","text":"Django-Ninja provides an intuitive way of handling custom exceptions by registering a function(handler) against an Exception type, just like it's done in a Flask app. So in that sense, Django-Ninja-Extra has an APIException exception type which provides similar functionalities, for those use to DRF APIException . For Example: from ninja_extra.exceptions import APIException from ninja_extra import api_controller , route , NinjaExtraAPI , status from ninja import constants class CustomAPIException ( APIException ): status_code = status . HTTP_401_UNAUTHORIZED message = 'UnAuthorized' @api_controller ( '' , tags = [ 'My Operations' ], auth = constants . NOT_SET , permissions = []) class MyController : @route . get ( '/exception' ) def custom_exception ( self ): raise CustomAPIException () api = NinjaExtraAPI ( title = 'Exception Test' ) api . register_controllers ( MyController )","title":"Custom Exception"},{"location":"tutorial/form/","text":"If you are not sure how to make a form post request like application/x-www-form-urlencode or multipart/form-data in django-ninja-extra, then this guide would be useful for you. Django-Ninja already covers most of the use cases here , but I will give you a quick summary here. Form Data as Params from ninja import Form , constants from ninja_extra import api_controller , http_post , router @api_controller ( '' , tags = [ 'My Operations' ], auth = constants . NOT_SET , permissions = []) class MyAPIController : @http_post ( \"/login\" ) def login ( self , username : str = Form ( ... ), password : str = Form ( ... )): return { 'username' : username , 'password' : '*****' } Two things to note here: You need to import Form from ninja module Use Form as default value for your parameter Info For more information on this, visit Django-Ninja Form tutorial","title":"Form Request"},{"location":"tutorial/form/#form-data-as-params","text":"from ninja import Form , constants from ninja_extra import api_controller , http_post , router @api_controller ( '' , tags = [ 'My Operations' ], auth = constants . NOT_SET , permissions = []) class MyAPIController : @http_post ( \"/login\" ) def login ( self , username : str = Form ( ... ), password : str = Form ( ... )): return { 'username' : username , 'password' : '*****' } Two things to note here: You need to import Form from ninja module Use Form as default value for your parameter Info For more information on this, visit Django-Ninja Form tutorial","title":"Form Data as Params"},{"location":"tutorial/ordering/","text":"Ordering Django Ninja Extra provides an intuitive ordering model using ordering decoration from the Django-Ninja-Extra ordering module. It expects a Queryset or a List from as a route function result. This feature was inspired by the DRF OrderingFilter Properties def ordering(func_or_ordering_class: Any = NOT_SET, **ordering_params: Any) -> Callable[..., Any]: func_or_ordering_class: Defines a route function or an Ordering Class. default: ninja_extra.ordering.Ordering ordering_params: extra parameters for initialising Ordering Class Changing Default Ordering Class To change the default ordering class, you need to add a NINJA_EXTRA variable in settings.py with a key ORDERING_CLASS and value defining path to ordering class # Django project settings.py INSTALLED_APPS = [ ... ] NINJA_EXTRA = { 'ORDERING_CLASS' : 'someapp.somemodule.CustomOrdering' } Usage If you do not specify the ordering_fields parameter, all fields from the QuerySet will be used for ordering. For example, to order users by username: http://example.com/api/users?ordering=username The client may also specify reverse orderings by prefixing the field name with '-', example: http://example.com/api/users?ordering=-username Multiple orderings may also be specified: http://example.com/api/users?ordering=username,email from typing import List from ninja_extra.ordering import ordering , Ordering from ninja_extra import api_controller , route , NinjaExtraAPI from ninja import ModelSchema from django.contrib.auth import get_user_model user_model = get_user_model () class UserSchema ( ModelSchema ): class Config : model = user_model model_fields = [ 'username' , 'email' ] @api_controller ( '/users' ) class UserController : @route . get ( '' , response = List [ UserSchema ]) @ordering ( Ordering , ordering_fields = [ 'username' , 'email' ]) def get_users ( self ): return user_model . objects . all () @route . get ( '/all-sort' , response = List [ UserSchema ]) @ordering def get_users_with_all_field_ordering ( self ): return [ u for u in user_model . objects . all ()] api = NinjaExtraAPI ( title = 'Ordering Test' ) api . register_controllers ( UserController ) Note If you use the paginate decorator and the ordering decorator together, the paginate decorator should be above the ordering decorator because first the data are sorted and then the data are paginated, for example: @route . get ( '' , response = List [ UserSchema ]) @paginate @ordering ( Ordering , ordering_fields = [ 'username' , 'email' ]) def get_users ( self ): return user_model . objects . all ()","title":"Ordering"},{"location":"tutorial/ordering/#ordering","text":"Django Ninja Extra provides an intuitive ordering model using ordering decoration from the Django-Ninja-Extra ordering module. It expects a Queryset or a List from as a route function result. This feature was inspired by the DRF OrderingFilter","title":"Ordering"},{"location":"tutorial/ordering/#properties","text":"def ordering(func_or_ordering_class: Any = NOT_SET, **ordering_params: Any) -> Callable[..., Any]: func_or_ordering_class: Defines a route function or an Ordering Class. default: ninja_extra.ordering.Ordering ordering_params: extra parameters for initialising Ordering Class","title":"Properties"},{"location":"tutorial/ordering/#changing-default-ordering-class","text":"To change the default ordering class, you need to add a NINJA_EXTRA variable in settings.py with a key ORDERING_CLASS and value defining path to ordering class # Django project settings.py INSTALLED_APPS = [ ... ] NINJA_EXTRA = { 'ORDERING_CLASS' : 'someapp.somemodule.CustomOrdering' }","title":"Changing Default Ordering Class"},{"location":"tutorial/ordering/#usage","text":"If you do not specify the ordering_fields parameter, all fields from the QuerySet will be used for ordering. For example, to order users by username: http://example.com/api/users?ordering=username The client may also specify reverse orderings by prefixing the field name with '-', example: http://example.com/api/users?ordering=-username Multiple orderings may also be specified: http://example.com/api/users?ordering=username,email from typing import List from ninja_extra.ordering import ordering , Ordering from ninja_extra import api_controller , route , NinjaExtraAPI from ninja import ModelSchema from django.contrib.auth import get_user_model user_model = get_user_model () class UserSchema ( ModelSchema ): class Config : model = user_model model_fields = [ 'username' , 'email' ] @api_controller ( '/users' ) class UserController : @route . get ( '' , response = List [ UserSchema ]) @ordering ( Ordering , ordering_fields = [ 'username' , 'email' ]) def get_users ( self ): return user_model . objects . all () @route . get ( '/all-sort' , response = List [ UserSchema ]) @ordering def get_users_with_all_field_ordering ( self ): return [ u for u in user_model . objects . all ()] api = NinjaExtraAPI ( title = 'Ordering Test' ) api . register_controllers ( UserController )","title":"Usage"},{"location":"tutorial/ordering/#note","text":"If you use the paginate decorator and the ordering decorator together, the paginate decorator should be above the ordering decorator because first the data are sorted and then the data are paginated, for example: @route . get ( '' , response = List [ UserSchema ]) @paginate @ordering ( Ordering , ordering_fields = [ 'username' , 'email' ]) def get_users ( self ): return user_model . objects . all ()","title":"Note"},{"location":"tutorial/pagination/","text":"Pagination Django Ninja Extra provides an intuitive pagination model using paginate decoration from the Django-Ninja-Extra pagination module. It expects a List or Queryset from as a route function result. Properties def paginate(func_or_pgn_class: Any = NOT_SET, **paginator_params: Any) -> Callable[..., Any]: func_or_pgn_class: Defines a route function or a Pagination Class. default: ninja_extra.pagination.LimitOffsetPagination paginator_params: extra parameters for initialising Pagination Class Info When using ninja_extra.pagination.LimitOffsetPagination , you should use NinjaPaginationResponseSchema as pagination response schema wrapper eg: @route . get ( '' , response = NinjaPaginationResponseSchema [ UserSchema ]) @paginate () def list_items ( self ): return item_model . objects . all () Changing Default Pagination Class To change the default pagination class, you need to add a NINJA_EXTRA variable in settings.py with a key PAGINATION_CLASS and value defining path to pagination class # Django project settings.py INSTALLED_APPS = [ ... ] NINJA_EXTRA = { 'PAGINATION_CLASS' : 'ninja_extra.pagination.PageNumberPaginationExtra' } Usage from typing import List from ninja_extra.pagination import ( paginate , PageNumberPaginationExtra , PaginatedResponseSchema ) from ninja_extra import api_controller , route , NinjaExtraAPI from ninja import ModelSchema from django.contrib.auth import get_user_model user_model = get_user_model () class UserSchema ( ModelSchema ): class Config : model = user_model model_fields = [ 'username' , 'email' ] @api_controller ( '/users' ) class UserController : @route . get ( '' , response = PaginatedResponseSchema [ UserSchema ]) @paginate ( PageNumberPaginationExtra , page_size = 50 ) def get_users ( self ): return user_model . objects . all () @route . get ( '/limit' , response = List [ UserSchema ]) @paginate def get_users_with_limit ( self ): # this will use default paginator class - ninja_extra.pagination.LimitOffsetPagination return user_model . objects . all () api = NinjaExtraAPI ( title = 'Pagination Test' ) api . register_controllers ( UserController )","title":"Pagination"},{"location":"tutorial/pagination/#pagination","text":"Django Ninja Extra provides an intuitive pagination model using paginate decoration from the Django-Ninja-Extra pagination module. It expects a List or Queryset from as a route function result.","title":"Pagination"},{"location":"tutorial/pagination/#properties","text":"def paginate(func_or_pgn_class: Any = NOT_SET, **paginator_params: Any) -> Callable[..., Any]: func_or_pgn_class: Defines a route function or a Pagination Class. default: ninja_extra.pagination.LimitOffsetPagination paginator_params: extra parameters for initialising Pagination Class Info When using ninja_extra.pagination.LimitOffsetPagination , you should use NinjaPaginationResponseSchema as pagination response schema wrapper eg: @route . get ( '' , response = NinjaPaginationResponseSchema [ UserSchema ]) @paginate () def list_items ( self ): return item_model . objects . all ()","title":"Properties"},{"location":"tutorial/pagination/#changing-default-pagination-class","text":"To change the default pagination class, you need to add a NINJA_EXTRA variable in settings.py with a key PAGINATION_CLASS and value defining path to pagination class # Django project settings.py INSTALLED_APPS = [ ... ] NINJA_EXTRA = { 'PAGINATION_CLASS' : 'ninja_extra.pagination.PageNumberPaginationExtra' }","title":"Changing Default Pagination Class"},{"location":"tutorial/pagination/#usage","text":"from typing import List from ninja_extra.pagination import ( paginate , PageNumberPaginationExtra , PaginatedResponseSchema ) from ninja_extra import api_controller , route , NinjaExtraAPI from ninja import ModelSchema from django.contrib.auth import get_user_model user_model = get_user_model () class UserSchema ( ModelSchema ): class Config : model = user_model model_fields = [ 'username' , 'email' ] @api_controller ( '/users' ) class UserController : @route . get ( '' , response = PaginatedResponseSchema [ UserSchema ]) @paginate ( PageNumberPaginationExtra , page_size = 50 ) def get_users ( self ): return user_model . objects . all () @route . get ( '/limit' , response = List [ UserSchema ]) @paginate def get_users_with_limit ( self ): # this will use default paginator class - ninja_extra.pagination.LimitOffsetPagination return user_model . objects . all () api = NinjaExtraAPI ( title = 'Pagination Test' ) api . register_controllers ( UserController )","title":"Usage"},{"location":"tutorial/path/","text":"Route path parameters are declared in python format-strings. for example: from ninja_extra import api_controller , route from ninja import constants @api_controller ( '' , tags = [ 'My Operations' ], auth = constants . NOT_SET , permissions = []) class MyAPIController : @route . get ( '/users/ {user_id} ' ) def get_user_by_id ( self , user_id : int ): return { 'user_id' : user_id } The value of the path parameter user_id will be passed to your function as the argument user_id . Info Read more","title":"Path Parameter"},{"location":"tutorial/query/","text":"Django-Ninja assumes function parameters that are not among path parameters as query parameters. For example: from ninja import constants from ninja_extra import api_controller , route @api_controller ( '' , tags = [ 'My Operations' ], auth = constants . NOT_SET , permissions = []) class MyAPIController : weapons = [ \"Ninjato\" , \"Shuriken\" , \"Katana\" , \"Kama\" , \"Kunai\" , \"Naginata\" , \"Yari\" ] @route . get ( \"/weapons\" ) def list_weapons ( self , limit : int = 10 , offset : int = 0 ): return self . weapons [ offset : offset + limit ] To query this operation, you use a URL like: http://localhost:8000/api/weapons?offset=0&limit=10 Info Read more","title":"Query Request"},{"location":"tutorial/schema/","text":"Django-Ninja Pydantic integration is one of the best features of Django-Ninja. With Pydantic, you can validate the inflow and outflow of data from your API, and It's very fast. Making a partial replacement of DRF serializers But if you want complete DRF Serializer replacement then Ninja-Schema is what you need. Ninja Schema Ninja Schema converts your Django ORM models to Pydantic schemas with more Pydantic features supported. Inspired by : django-ninja and djantic Key features: Custom Field Support : Ninja Schema converts django model to native pydantic types which gives you quick field validation out of the box. eg Enums, email, IPAddress, URLs, JSON, etc Field Validator : Fields can be validated with model_validator just like pydantic validator or root_validator . Info Visit Ninja Schema for More information Accessing Request Object in Schema Django Ninja Extra provides RouteContext object which available during request lifecycle. The RouteContext holds","title":"Schema"},{"location":"tutorial/schema/#ninja-schema","text":"Ninja Schema converts your Django ORM models to Pydantic schemas with more Pydantic features supported. Inspired by : django-ninja and djantic Key features: Custom Field Support : Ninja Schema converts django model to native pydantic types which gives you quick field validation out of the box. eg Enums, email, IPAddress, URLs, JSON, etc Field Validator : Fields can be validated with model_validator just like pydantic validator or root_validator . Info Visit Ninja Schema for More information","title":"Ninja Schema"},{"location":"tutorial/schema/#accessing-request-object-in-schema","text":"Django Ninja Extra provides RouteContext object which available during request lifecycle. The RouteContext holds","title":"Accessing Request Object in Schema"},{"location":"tutorial/searching/","text":"Searching Django Ninja Extra provides an intuitive searching model using searching decoration from the Django-Ninja-Extra searching module. It expects a Queryset or a List from as a route function result. This feature was inspired by the DRF SearchFilter Properties def searching(func_or_searching_class: Any = NOT_SET, **searching_params: Any) -> Callable[..., Any]: func_or_searching_class: Defines a route function or an Searching Class. default: ninja_extra.searching.Searching searching_params: extra parameters for initialising Searching Class Changing Default Searching Class To change the default searching class, you need to add a NINJA_EXTRA variable in settings.py with a key SEARCHING_CLASS and value defining path to searching class # Django project settings.py INSTALLED_APPS = [ ... ] NINJA_EXTRA = { 'SEARCHING_CLASS' : 'someapp.somemodule.CustomSearching' } Usage If you do not specify the search_fields parameter, will return the result without change. For example, to search users by username or email: http://example.com/api/users?search=someuser You can also perform a related lookup on a ForeignKey or ManyToManyField with the lookup API double-underscore notation: search_fields = ['username', 'email', 'profile__profession'] By default, searches will use case-insensitive partial matches. The search parameter may contain multiple search terms, which should be whitespace and/or comma separated. If multiple search terms are used then objects will be returned in the list only if all the provided terms are matched. The search behavior may be restricted by prepending various characters to the search_fields . '^' Starts-with search. '=' Exact matches. '@' Full-text search. (Currently only supported Django's PostgreSQL backend .) '$' Regex search. For example: > search_fields = ['=username', '=email'] from typing import List from ninja_extra.searching import searching , Searching from ninja_extra import api_controller , route , NinjaExtraAPI from ninja import ModelSchema from django.contrib.auth import get_user_model user_model = get_user_model () class UserSchema ( ModelSchema ): class Config : model = user_model model_fields = [ 'username' , 'email' ] @api_controller ( '/users' ) class UserController : @route . get ( '' , response = List [ UserSchema ]) @searching ( Searching , search_fields = [ 'username' , 'email' ]) def get_users ( self ): return user_model . objects . all () @route . get ( '/iexact-email' , response = List [ UserSchema ]) @searching ( search_fields = [ '=email' ]) def get_users_with_search_iexact_email ( self ): return [ u for u in user_model . objects . all ()] api = NinjaExtraAPI ( title = 'Searching Test' ) api . register_controllers ( UserController ) Note If you use the paginate decorator, the ordering decorator and the searching decorator together, the paginate decorator should be above the ordering decorator and the ordering decorator should be above the searching decorator because first the data is filtered, then the data is sorted and then paginated:, for example: @route . get ( '' , response = List [ UserSchema ]) @paginate @ordering ( Ordering , ordering_fields = [ 'username' , 'email' ]) @searching ( Searching , search_fields = [ 'username' , 'email' ]) def get_users ( self ): return user_model . objects . all ()","title":"Searching"},{"location":"tutorial/searching/#searching","text":"Django Ninja Extra provides an intuitive searching model using searching decoration from the Django-Ninja-Extra searching module. It expects a Queryset or a List from as a route function result. This feature was inspired by the DRF SearchFilter","title":"Searching"},{"location":"tutorial/searching/#properties","text":"def searching(func_or_searching_class: Any = NOT_SET, **searching_params: Any) -> Callable[..., Any]: func_or_searching_class: Defines a route function or an Searching Class. default: ninja_extra.searching.Searching searching_params: extra parameters for initialising Searching Class","title":"Properties"},{"location":"tutorial/searching/#changing-default-searching-class","text":"To change the default searching class, you need to add a NINJA_EXTRA variable in settings.py with a key SEARCHING_CLASS and value defining path to searching class # Django project settings.py INSTALLED_APPS = [ ... ] NINJA_EXTRA = { 'SEARCHING_CLASS' : 'someapp.somemodule.CustomSearching' }","title":"Changing Default Searching Class"},{"location":"tutorial/searching/#usage","text":"If you do not specify the search_fields parameter, will return the result without change. For example, to search users by username or email: http://example.com/api/users?search=someuser You can also perform a related lookup on a ForeignKey or ManyToManyField with the lookup API double-underscore notation: search_fields = ['username', 'email', 'profile__profession'] By default, searches will use case-insensitive partial matches. The search parameter may contain multiple search terms, which should be whitespace and/or comma separated. If multiple search terms are used then objects will be returned in the list only if all the provided terms are matched. The search behavior may be restricted by prepending various characters to the search_fields . '^' Starts-with search. '=' Exact matches. '@' Full-text search. (Currently only supported Django's PostgreSQL backend .) '$' Regex search. For example: > search_fields = ['=username', '=email'] from typing import List from ninja_extra.searching import searching , Searching from ninja_extra import api_controller , route , NinjaExtraAPI from ninja import ModelSchema from django.contrib.auth import get_user_model user_model = get_user_model () class UserSchema ( ModelSchema ): class Config : model = user_model model_fields = [ 'username' , 'email' ] @api_controller ( '/users' ) class UserController : @route . get ( '' , response = List [ UserSchema ]) @searching ( Searching , search_fields = [ 'username' , 'email' ]) def get_users ( self ): return user_model . objects . all () @route . get ( '/iexact-email' , response = List [ UserSchema ]) @searching ( search_fields = [ '=email' ]) def get_users_with_search_iexact_email ( self ): return [ u for u in user_model . objects . all ()] api = NinjaExtraAPI ( title = 'Searching Test' ) api . register_controllers ( UserController )","title":"Usage"},{"location":"tutorial/searching/#note","text":"If you use the paginate decorator, the ordering decorator and the searching decorator together, the paginate decorator should be above the ordering decorator and the ordering decorator should be above the searching decorator because first the data is filtered, then the data is sorted and then paginated:, for example: @route . get ( '' , response = List [ UserSchema ]) @paginate @ordering ( Ordering , ordering_fields = [ 'username' , 'email' ]) @searching ( Searching , search_fields = [ 'username' , 'email' ]) def get_users ( self ): return user_model . objects . all ()","title":"Note"},{"location":"tutorial/testing/","text":"Testing APIController Django Ninja Extra has a TestClient that provides seamless testing of ControllerBase classes with pytest There are two test clients TestClient : for synchronous route functions TestAsyncClient : for asynchronous route functions Both TestClient and TestAsyncClient inherit from the Django Ninja TestClient class which provides the base functionality for making requests to the application, and both of them also have similar methods such as get , post , put , patch , delete , and options for making requests to the application. For example, to test a GET request to the /users endpoint, you can use the TestClient as follows: import pytest from .controllers import UserController from ninja_extra.testing import TestClient @pytest . mark . django_db class TestMyMathController : def test_get_users ( self ): client = TestClient ( UserController ) response = client . get ( '/users' ) assert response . status_code == 200 assert response . json ()[ 0 ] == { 'first_name' : 'Ninja Extra' , 'username' : 'django_ninja' , 'email' : 'john.doe@gmail.com' } Similarly, for testing an asynchronous route function, you can use TestClientAsync as follows: from ninja_extra import api_controller , route from ninja_extra.testing import TestAsyncClient @api_controller ( '' , tags = [ 'Math' ]) class MyMathController : @route . get ( '/add' ,) async def add ( self , a : int , b : int ): \"\"\"add a to b\"\"\" return { \"result\" : a - b } class TestMyMathController : def test_get_users_async ( self ): client = TestAsyncClient ( MyMathController ) response = client . get ( '/add' , query = dict ( a = 3 , b = 5 )) assert response . status_code == 200 assert response . json () == { \"result\" : - 2 }","title":"Testing"},{"location":"tutorial/testing/#testing-apicontroller","text":"Django Ninja Extra has a TestClient that provides seamless testing of ControllerBase classes with pytest There are two test clients TestClient : for synchronous route functions TestAsyncClient : for asynchronous route functions Both TestClient and TestAsyncClient inherit from the Django Ninja TestClient class which provides the base functionality for making requests to the application, and both of them also have similar methods such as get , post , put , patch , delete , and options for making requests to the application. For example, to test a GET request to the /users endpoint, you can use the TestClient as follows: import pytest from .controllers import UserController from ninja_extra.testing import TestClient @pytest . mark . django_db class TestMyMathController : def test_get_users ( self ): client = TestClient ( UserController ) response = client . get ( '/users' ) assert response . status_code == 200 assert response . json ()[ 0 ] == { 'first_name' : 'Ninja Extra' , 'username' : 'django_ninja' , 'email' : 'john.doe@gmail.com' } Similarly, for testing an asynchronous route function, you can use TestClientAsync as follows: from ninja_extra import api_controller , route from ninja_extra.testing import TestAsyncClient @api_controller ( '' , tags = [ 'Math' ]) class MyMathController : @route . get ( '/add' ,) async def add ( self , a : int , b : int ): \"\"\"add a to b\"\"\" return { \"result\" : a - b } class TestMyMathController : def test_get_users_async ( self ): client = TestAsyncClient ( MyMathController ) response = client . get ( '/add' , query = dict ( a = 3 , b = 5 )) assert response . status_code == 200 assert response . json () == { \"result\" : - 2 }","title":"Testing APIController"},{"location":"tutorial/throttling/","text":"Throttling Throttling can be seen as a permission that determines if a request should be authorized. It indicates a temporary state used to control the rate of requests that clients can make to an API. from ninja_extra import NinjaExtraAPI , throttle api = NinjaExtraAPI () @api . get ( '/users' ) @throttle # this will apply default throttle classes [UserRateThrottle, AnonRateThrottle] def my_throttled_endpoint ( request ): return 'foo' Info The above example won't be throttled because the default scope for UserRateThrottle and AnonRateThrottle is none Multiple Throttling Django-ninja-extra throttle supposes multiple throttles which is useful to impose different constraints, which could be burst throttling rate or sustained throttling rates, on an API. for example, you might want to limit a user to a maximum of 60 requests per minute, and 1000 requests per day. from ninja_extra import NinjaExtraAPI , throttle from ninja_extra.throttling import UserRateThrottle api = NinjaExtraAPI () class User60MinRateThrottle ( UserRateThrottle ): rate = \"60/min\" scope = \"minutes\" class User1000PerDayRateThrottle ( UserRateThrottle ): rate = \"1000/day\" scope = \"days\" @api . get ( '/users' ) @throttle ( User60MinRateThrottle , User1000PerDayRateThrottle ) def my_throttled_endpoint ( request ): return 'foo' Throttling Policy Settings You can set globally default throttling classes and rates in your project settings.py by overriding the keys below: # django settings.py NINJA_EXTRA = { 'THROTTLE_CLASSES' : [ \"ninja_extra.throttling.AnonRateThrottle\" , \"ninja_extra.throttling.UserRateThrottle\" , ], 'THROTTLE_RATES' : { 'user' : '1000/day' , 'anon' : '100/day' , }, 'NUM_PROXIES' : None } The rate descriptions used in THROTTLE_RATES may include second , minute , hour or day as the throttle period. from ninja_extra import NinjaExtraAPI , throttle from ninja_extra.throttling import UserRateThrottle api = NinjaExtraAPI () @api . get ( '/users' ) @throttle ( UserRateThrottle ) def my_throttled_endpoint ( request ): return 'foo' Clients Identification Clients are identified by x-Forwarded-For in HTTP header and REMOTE_ADDR from WSGI variable. These are unique identities which identifies clients IP addresses used for throttling. X-Forwarded-For is preferable over REMOTE_ADDR and is used as so. Limit Clients Proxies If you need to strictly identify unique client IP addresses, you'll need to first configure the number of application proxies that the API runs behind by setting the NUM_PROXIES setting. This setting should be an integer of zero or more. If set to non-zero then the client IP will be identified as being the last IP address in the X-Forwarded-For header, once any application proxy IP addresses have first been excluded. If set to zero, then the REMOTE_ADDR value will always be used as the identifying IP address. It is important to understand that if you configure the NUM_PROXIES setting, then all clients behind a unique NAT'd gateway will be treated as a single client. Info Further context on how the X-Forwarded-For header works, and identifying a remote client IP can be found here. Throttling Model Cache setup The throttling models used in django-ninja-extra utilizes Django cache backend. It uses the default value of LocMemCache See Django's cache documentation for more details. If you dont want to use the default cache defined in throttle model, here is an example on how to define a different cache for a throttling model from django.core.cache import caches from ninja_extra.throttling import AnonRateThrottle class CustomAnonRateThrottle ( AnonRateThrottle ): cache = caches [ 'alternate' ] API Reference AnonRateThrottle AnonRateThrottle model is for throttling unauthenticated users using their IP address as key to throttle against. It is suitable for restricting rate of requests from an unknown source Request Permission is determined by: - rate defined in derived class - anon scope defined in THROTTLE_RATES in NINJA_EXTRA settings in settings.py UserRateThrottle UserRateThrottle model is for throttling authenticated users using user id or pk to generate a key to throttle against. Unauthenticated requests will fall back to using the IP address of the incoming request to generate a unique key to throttle against. Request Permission is determined by: - rate defined in derived class - user scope defined in THROTTLE_RATES in NINJA_EXTRA settings in settings.py You can use multiple user throttle rates for a UserRateThrottle model, for example: # example/throttles.py from ninja_extra.throttling import UserRateThrottle class BurstRateThrottle ( UserRateThrottle ): scope = 'burst' class SustainedRateThrottle ( UserRateThrottle ): scope = 'sustained' # django settings.py NINJA_EXTRA = { 'THROTTLE_CLASSES' : [ 'example.throttles.BurstRateThrottle' , 'example.throttles.SustainedRateThrottle' ], 'THROTTLE_RATES' : { 'burst' : '60/min' , 'sustained' : '1000/day' } } DynamicRateThrottle DynamicRateThrottle model is for throttling authenticated and unauthenticated users in similar way as UserRateThrottle . Its key feature is in the ability to dynamically set scope where its used. for an example: we can defined a scope in settings # django settings.py NINJA_EXTRA = { 'THROTTLE_RATES' : { 'burst' : '60/min' , 'sustained' : '1000/day' } } # api.py from ninja_extra import NinjaExtraAPI , throttle from ninja_extra.throttling import DynamicRateThrottle api = NinjaExtraAPI () @api . get ( '/users' ) @throttle ( DynamicRateThrottle , scope = 'burst' ) def get_users ( request ): return 'foo' @api . get ( '/users/<int:id>' ) @throttle ( DynamicRateThrottle , scope = 'sustained' ) def get_user_by_id ( request , id : int ): return 'foo' Here, we dynamically applied sustained rates and burst rates to get_users and get_user_by_id respectively new in v0.15.8 You can throttle all controller endpoints actions at the controller class level Controller Throttling # api.py from ninja_extra import ( NinjaExtraAPI , throttle , api_controller , ControllerBase , http_get ) from ninja_extra.throttling import DynamicRateThrottle api = NinjaExtraAPI () @api_controller ( \"/throttled-controller\" ) class ThrottlingControllerSample ( ControllerBase ): throttling_classes = [ DynamicRateThrottle , ] throttling_init_kwargs = dict ( scope = \"sustained\" ) @http_get ( \"/endpoint_1\" ) @throttle ( DynamicRateThrottle , scope = 'burst' ) def endpoint_1 ( self , request ): # this will override the generally throttling applied at the controller return \"foo\" @http_get ( \"/endpoint_2\" ) def endpoint_2 ( self , request ): return \"foo\" @http_get ( \"/endpoint_3\" ) def endpoint_3 ( self , request ): return \"foo\" api . register_controllers ( ThrottlingControllerSample )","title":"Throttling"},{"location":"tutorial/throttling/#throttling","text":"Throttling can be seen as a permission that determines if a request should be authorized. It indicates a temporary state used to control the rate of requests that clients can make to an API. from ninja_extra import NinjaExtraAPI , throttle api = NinjaExtraAPI () @api . get ( '/users' ) @throttle # this will apply default throttle classes [UserRateThrottle, AnonRateThrottle] def my_throttled_endpoint ( request ): return 'foo' Info The above example won't be throttled because the default scope for UserRateThrottle and AnonRateThrottle is none","title":"Throttling"},{"location":"tutorial/throttling/#multiple-throttling","text":"Django-ninja-extra throttle supposes multiple throttles which is useful to impose different constraints, which could be burst throttling rate or sustained throttling rates, on an API. for example, you might want to limit a user to a maximum of 60 requests per minute, and 1000 requests per day. from ninja_extra import NinjaExtraAPI , throttle from ninja_extra.throttling import UserRateThrottle api = NinjaExtraAPI () class User60MinRateThrottle ( UserRateThrottle ): rate = \"60/min\" scope = \"minutes\" class User1000PerDayRateThrottle ( UserRateThrottle ): rate = \"1000/day\" scope = \"days\" @api . get ( '/users' ) @throttle ( User60MinRateThrottle , User1000PerDayRateThrottle ) def my_throttled_endpoint ( request ): return 'foo'","title":"Multiple Throttling"},{"location":"tutorial/throttling/#throttling-policy-settings","text":"You can set globally default throttling classes and rates in your project settings.py by overriding the keys below: # django settings.py NINJA_EXTRA = { 'THROTTLE_CLASSES' : [ \"ninja_extra.throttling.AnonRateThrottle\" , \"ninja_extra.throttling.UserRateThrottle\" , ], 'THROTTLE_RATES' : { 'user' : '1000/day' , 'anon' : '100/day' , }, 'NUM_PROXIES' : None } The rate descriptions used in THROTTLE_RATES may include second , minute , hour or day as the throttle period. from ninja_extra import NinjaExtraAPI , throttle from ninja_extra.throttling import UserRateThrottle api = NinjaExtraAPI () @api . get ( '/users' ) @throttle ( UserRateThrottle ) def my_throttled_endpoint ( request ): return 'foo'","title":"Throttling Policy Settings"},{"location":"tutorial/throttling/#clients-identification","text":"Clients are identified by x-Forwarded-For in HTTP header and REMOTE_ADDR from WSGI variable. These are unique identities which identifies clients IP addresses used for throttling. X-Forwarded-For is preferable over REMOTE_ADDR and is used as so.","title":"Clients Identification"},{"location":"tutorial/throttling/#limit-clients-proxies","text":"If you need to strictly identify unique client IP addresses, you'll need to first configure the number of application proxies that the API runs behind by setting the NUM_PROXIES setting. This setting should be an integer of zero or more. If set to non-zero then the client IP will be identified as being the last IP address in the X-Forwarded-For header, once any application proxy IP addresses have first been excluded. If set to zero, then the REMOTE_ADDR value will always be used as the identifying IP address. It is important to understand that if you configure the NUM_PROXIES setting, then all clients behind a unique NAT'd gateway will be treated as a single client. Info Further context on how the X-Forwarded-For header works, and identifying a remote client IP can be found here.","title":"Limit Clients Proxies"},{"location":"tutorial/throttling/#throttling-model-cache-setup","text":"The throttling models used in django-ninja-extra utilizes Django cache backend. It uses the default value of LocMemCache See Django's cache documentation for more details. If you dont want to use the default cache defined in throttle model, here is an example on how to define a different cache for a throttling model from django.core.cache import caches from ninja_extra.throttling import AnonRateThrottle class CustomAnonRateThrottle ( AnonRateThrottle ): cache = caches [ 'alternate' ]","title":"Throttling Model Cache setup"},{"location":"tutorial/throttling/#api-reference","text":"","title":"API Reference"},{"location":"tutorial/throttling/#anonratethrottle","text":"AnonRateThrottle model is for throttling unauthenticated users using their IP address as key to throttle against. It is suitable for restricting rate of requests from an unknown source Request Permission is determined by: - rate defined in derived class - anon scope defined in THROTTLE_RATES in NINJA_EXTRA settings in settings.py","title":"AnonRateThrottle"},{"location":"tutorial/throttling/#userratethrottle","text":"UserRateThrottle model is for throttling authenticated users using user id or pk to generate a key to throttle against. Unauthenticated requests will fall back to using the IP address of the incoming request to generate a unique key to throttle against. Request Permission is determined by: - rate defined in derived class - user scope defined in THROTTLE_RATES in NINJA_EXTRA settings in settings.py You can use multiple user throttle rates for a UserRateThrottle model, for example: # example/throttles.py from ninja_extra.throttling import UserRateThrottle class BurstRateThrottle ( UserRateThrottle ): scope = 'burst' class SustainedRateThrottle ( UserRateThrottle ): scope = 'sustained' # django settings.py NINJA_EXTRA = { 'THROTTLE_CLASSES' : [ 'example.throttles.BurstRateThrottle' , 'example.throttles.SustainedRateThrottle' ], 'THROTTLE_RATES' : { 'burst' : '60/min' , 'sustained' : '1000/day' } }","title":"UserRateThrottle"},{"location":"tutorial/throttling/#dynamicratethrottle","text":"DynamicRateThrottle model is for throttling authenticated and unauthenticated users in similar way as UserRateThrottle . Its key feature is in the ability to dynamically set scope where its used. for an example: we can defined a scope in settings # django settings.py NINJA_EXTRA = { 'THROTTLE_RATES' : { 'burst' : '60/min' , 'sustained' : '1000/day' } } # api.py from ninja_extra import NinjaExtraAPI , throttle from ninja_extra.throttling import DynamicRateThrottle api = NinjaExtraAPI () @api . get ( '/users' ) @throttle ( DynamicRateThrottle , scope = 'burst' ) def get_users ( request ): return 'foo' @api . get ( '/users/<int:id>' ) @throttle ( DynamicRateThrottle , scope = 'sustained' ) def get_user_by_id ( request , id : int ): return 'foo' Here, we dynamically applied sustained rates and burst rates to get_users and get_user_by_id respectively new in v0.15.8 You can throttle all controller endpoints actions at the controller class level","title":"DynamicRateThrottle"},{"location":"tutorial/throttling/#controller-throttling","text":"# api.py from ninja_extra import ( NinjaExtraAPI , throttle , api_controller , ControllerBase , http_get ) from ninja_extra.throttling import DynamicRateThrottle api = NinjaExtraAPI () @api_controller ( \"/throttled-controller\" ) class ThrottlingControllerSample ( ControllerBase ): throttling_classes = [ DynamicRateThrottle , ] throttling_init_kwargs = dict ( scope = \"sustained\" ) @http_get ( \"/endpoint_1\" ) @throttle ( DynamicRateThrottle , scope = 'burst' ) def endpoint_1 ( self , request ): # this will override the generally throttling applied at the controller return \"foo\" @http_get ( \"/endpoint_2\" ) def endpoint_2 ( self , request ): return \"foo\" @http_get ( \"/endpoint_3\" ) def endpoint_3 ( self , request ): return \"foo\" api . register_controllers ( ThrottlingControllerSample )","title":"Controller Throttling"},{"location":"tutorial/versioning/","text":"Versioning Different API version numbers With Django Ninja Extra , it's very much easy to run multiple API versions from a single Django project. All you have to do is create two or more NinjaAPI instances with different version arguments: api_v1.py : from ninja_extra import NinjaExtraAPI , route , api_controller @api_controller class MyV1Controller : @route . get ( '/hello' ) def hello ( self ): return { 'message' : 'Hello from V1' } @route . get ( '/example' ) def example ( self ): return { 'message' : 'Hello from V1 Example' } api = NinjaExtraAPI ( version = '1.0.0' ) api . register_controllers ( MyV1Controller ) api_ v2 .py: You can reuse your APIControllers and make modifications to specific routes. from ninja_extra import NinjaExtraAPI , route , api_controller from .api_v1 import MyV1Controller @api_controller class MyV2Controller ( MyV1Controller ): @route . get ( '/example' ) def example ( self ): return { 'message' : 'Hello from V2 Example' } api = NinjaExtraAPI ( version = '2.0.0' ) api . register_controllers ( MyV2Controller ) and then in urls.py : ... from api_v1 import api as api_v1 from api_v2 import api as api_v2 urlpatterns = [ ... path ( 'api/v1/' , api_v1 . urls ), path ( 'api/v2/' , api_v2 . urls ), ] Now you can go to different OpenAPI docs pages for each version: http://127.0.0.1/api/ v1 /docs http://127.0.0.1/api/ v2 /docs Different business logic In the same way, you can define a different API for different components or areas: ... api = NinjaExtraAPI ( auth = token_auth , urls_namespace = 'public_api' ) ... api_private = NinjaExtraAPI ( auth = session_auth , urls_namespace = 'private_api' ) ... urlpatterns = [ ... path ( 'api/' , api . urls ), path ( 'internal-api/' , api_private . urls ), ] Note If you use different NinjaExtraAPI instances, you need to define different version s or different urls_namespace s. This is the same with NinjaAPI instances","title":"Versioning"},{"location":"tutorial/versioning/#versioning","text":"","title":"Versioning"},{"location":"tutorial/versioning/#different-api-version-numbers","text":"With Django Ninja Extra , it's very much easy to run multiple API versions from a single Django project. All you have to do is create two or more NinjaAPI instances with different version arguments: api_v1.py : from ninja_extra import NinjaExtraAPI , route , api_controller @api_controller class MyV1Controller : @route . get ( '/hello' ) def hello ( self ): return { 'message' : 'Hello from V1' } @route . get ( '/example' ) def example ( self ): return { 'message' : 'Hello from V1 Example' } api = NinjaExtraAPI ( version = '1.0.0' ) api . register_controllers ( MyV1Controller ) api_ v2 .py: You can reuse your APIControllers and make modifications to specific routes. from ninja_extra import NinjaExtraAPI , route , api_controller from .api_v1 import MyV1Controller @api_controller class MyV2Controller ( MyV1Controller ): @route . get ( '/example' ) def example ( self ): return { 'message' : 'Hello from V2 Example' } api = NinjaExtraAPI ( version = '2.0.0' ) api . register_controllers ( MyV2Controller ) and then in urls.py : ... from api_v1 import api as api_v1 from api_v2 import api as api_v2 urlpatterns = [ ... path ( 'api/v1/' , api_v1 . urls ), path ( 'api/v2/' , api_v2 . urls ), ] Now you can go to different OpenAPI docs pages for each version: http://127.0.0.1/api/ v1 /docs http://127.0.0.1/api/ v2 /docs","title":"Different API version numbers"},{"location":"tutorial/versioning/#different-business-logic","text":"In the same way, you can define a different API for different components or areas: ... api = NinjaExtraAPI ( auth = token_auth , urls_namespace = 'public_api' ) ... api_private = NinjaExtraAPI ( auth = session_auth , urls_namespace = 'private_api' ) ... urlpatterns = [ ... path ( 'api/' , api . urls ), path ( 'internal-api/' , api_private . urls ), ] Note If you use different NinjaExtraAPI instances, you need to define different version s or different urls_namespace s. This is the same with NinjaAPI instances","title":"Different business logic"}]}